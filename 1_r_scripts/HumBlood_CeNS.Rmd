---
title: "Comparative Hummingbird Blood: Cell Size vs. Cell Number (CeNS) Analyses"
author: "Jessie Williamson"
date: "4/26/2021; last revised 6/02/21"
output: html_document
---

Script to try to get to the bottom of 'cell size vs. cell number' and create the CeNS index. 


**This script has 2 parts:** 

**1) CeNS Models:** 
    a) indiviual-level dataset
    b) species-mean dataset 
    c) single-species models for well-sampled species 
    
**2) CeNS index:** 
    - Take results of single-species models to calculate this. Formula is: TRBC estimate/(MCV estimate + TRBC estimate).
    - Is there phylo signal to these estimates? Prune trees, then work up contmaps, Pagel's lamda, and blomberg's K
    - Take these estimates and run another model: maybe try cens.index ~ mass + elev + (1|phylo) to see what predicts this index? —> This is making that censdat cool jump that Chris mentioned, where we’ll show that something additional PREDICTS our index.


#######


```{R, echo=FALSE}
# GLOBAL R chunk options here (hide message w/ echo=FALSE)
knitr::opts_chunk$set(comment = NA, message = FALSE, warning = FALSE, width = 100)
knitr::opts_chunk$set(fig.align = "center", fig.height = 4, fig.width = 6)
knitr::opts_chunk$set(cache = TRUE, autodep=TRUE)
```


# Load packages
```{R}
library(reshape)
library(reshape2)
library(plyr)
library(dplyr)
library(car)
library(GGally)
library(Hmisc)
library(gridExtra)
library(stats)
library(gplots)
library(ggplot2)
library(stats4) # Forces knitr to work when it's being wonky
library(PMCMR) #Allows Kruskal-Wallis post-hocs
library(effects)
library(gridExtra)
library(lattice)
# library(survival)
# library(fmsb)
library(faraway)
library(tidyverse)
library(patchwork) 
library(viridis)
library(rcompanion) # for Tukey's Ladder of Powers Transformation
library(purrr)
library(tidyr)
library(cowplot)
library(gganimate)
library(job) # Run slow brms models as jobs to free up console

# Bayesian modeling packages 
library(MCMCglmm)
library(bayesplot)
library(rstan)
library(Rcpp) # required for brms
library(brms) # updated to 2.15.0 on 3/29/21
library(bayesplot) # appears to be required for bayesplot::pp_check?
library(ggdist)
library(tidybayes)
library(performance)
library(bayestestR) # for effective sample size tests

# To run each time you load rstan
options(mc.cores = parallel::detectCores()) # for core setup 
rstan_options(auto_write = TRUE) # auto save  bare verion of compiled Stan program to HD
# rstan output should always end in a blank line w/ no characters or spaces  

# Phylo packages 
library(phytools)
# library(ape)

# Frequentist modeling packages
# library(nlme)
# library(lme4)
# library(AICcmodavg)
# library(MuMIn)
# library(glmulti)
# library(lsmeans)
# library(rsq) # get r-squared values from GLM
# library(r2glmm) # for R^2 values from lmer() and glmer()
# library(multcompView) # related to multiple comparisons?
# library(jtools) # interaction plots 
# library(interactions) # interaction plots 
# library(broom)
# library(stargazer) # model output tables
# library(ggeffects) # for estimating model predictions from mixed effects models
```


---

# Clear workspace and set WD
```{R}
rm(list=ls(all=TRUE)) # clear workspace 
setwd("/Users/Jessie/Dropbox (MSBbirds)/Rdirectory/ComparativeHummingbirdBlood")
```


# Load in datasets
```{R}
# Load functions 
source("/Users/Jessie/Dropbox (MSBbirds)/Rdirectory/ComparativeHummingbirdBlood/1_r_scripts/ada_functions.R") 
  # Erik's ADA functions for clean & collated lm diag plots
source("/Users/Jessie/Dropbox (MSBbirds)/Rdirectory/ComparativeHummingbirdBlood/1_r_scripts/Rfunctions.R") # Nora's functions

# Final hummingbird blood dataset (remember that you completed pre-processing in HumBlood_Modeling file)
final <- read.csv("ComparativeHummingbirdBlood_FinalDataset_ForModeling_04-26-21.csv", stringsAsFactors = FALSE)
  # Keep stringsasfactors=FALSE because species and dept need to be characters in order for Patagona rename loop to work
final <- final[ , !(colnames(final) %in% c("X"))] # drop weird X column 1 if reading in from read.csv

# # Phylogeny pruned from McGuire and adjusted (see script HumBlood_Phylogeny.Rmd)
# tree <- read.tree("McGuirePruned_AllHummingbirdComparativeTree_FINAL.tre") # a list 
# tree$tip.label # Check 77 tips
# 
# # Write out final tree file as pdf for figure-making
# # In order to write out .pdf tree file: 1) Initiate pdf (or jpeg, etc) file; 2) Plot tree w/ all graphics; 3) dev.off to save
# pdf("McGuirePruned_AllHummingbirdComparativeTree_FINAL.pdf", width=5, height=6) 
# plotTree(tree, ftype="i") # Check this pre-final tree w/ adjusted branch lengths 
# dev.off()
# 
# # Read in sub trees 
# tree.hb <- read.tree("McGuirePruned_AllHummingbirdComparative_Tree.hb_FINAL.tre")  
# tree.hct <- read.tree("McGuirePruned_AllHummingbirdComparativeTree.hct_FINAL.tre")  
# tree.trbc <- read.tree("McGuirePruned_AllHummingbirdComparativeTree.trbc_FINAL.tre") 
# tree.mcv <- read.tree("McGuirePruned_AllHummingbirdComparativeTree.mcv_FINAL.tre") 
# tree.mch <- read.tree("McGuirePruned_AllHummingbirdComparativeTree.mch_FINAL.tre") 
# tree.mchc <- read.tree("McGuirePruned_AllHummingbirdComparativeTree.mchc_FINAL.tre")
```


# Pre-processing for modeling - individual-level data 
```{r}
# Subset the data to just blood variables of interest
# We could alternatively use 'final' dataset and model will remove NAs for us, but this is a little bit cleaner. 
censdat <- subset(final, select=c(species, rowID, nk, department, month, elev, mass, wl, hb, mcv, mcv.log, trbc, mchc, genotype)) 
  # dept needed for filtering of patagona for species mean data
censdat <- na.omit(censdat) # 661 observations 

# We don't need to check normality and transform because we did that during pre-processing in HumBlood_Modeling. 
# We know MCV has heavy tails, respons well to skew_normal, but *might* fit better with mcv.log variable - we'll see below.

# Standardize predictors 
censdat$mcv.z <- standardize(censdat$mcv)
censdat$trbc.z <- standardize(censdat$trbc)

# Correlation matrix 
cor(censdat[,c("hb", "mcv.z", "trbc.z")])
# Strong negative correlation  between TRBC and MCV, but these two are very different measures and essential to 
# understanding how birds increase [Hb]; for this reason, we justify leaving both in models. 

censdat$species <- as.character(censdat$species)
censdat$department <- as.character(censdat$department)

# Loop through dataset and assign "Patagona_gigas_S" to Chilean birds and "Patagona_gigas_N" to Peru birds
# Species and Department MUST be characters in order for this to work 
for(i in 1:nrow(censdat)){
    if((censdat$species[i] == "Patagona_gigas") & (censdat$department[i] == "Región Valparaíso") ){
        censdat$species[i] <- "Patagona_gigas_S"
    }else if((censdat$species[i] == "Patagona_gigas")){ 
      censdat$species[i] <- "Patagona_gigas_N"
    }
}

# Since we're considering Patagona as two functionally separate species, eliminate possible southern migrants that were 
# sampled during the austral non-breeding winter (July, Aug, September; we have no June birds)
censdat <- censdat[-which(censdat$species == "Patagona_gigas_N" & censdat$month == "July"),] 
censdat <- censdat[-which(censdat$species == "Patagona_gigas_N" & censdat$month == "August"),]
censdat <- censdat[-which(censdat$species == "Patagona_gigas_N" & censdat$month == "September"),]

# # NOW check structures and convert characters to factors 
str(censdat)
censdat$species <- as.factor(censdat$species)
censdat$department <- as.factor(censdat$department)

# Make department names consistent; remove 'í' characters in case R is reading them in incorrectly
# And must do this here after as.factor() because this only works on FACTORS 
levels(censdat$department)[levels(censdat$department)=="Valparaíso"] <- "Valparaiso"
levels(censdat$department)[levels(censdat$department)=="Región Valparaíso"] <- "Valparaiso"

# Predictor dataset - take a look at distributions
# p <- ggpairs(subset(censdat, select = c(hb, mcv, trbc, mcv.log, mcv.z, trbc.z))); print(p)
```


# Pre-processing for modeling - species mean data 
```{r}
cens.sp <- censdat # Make the final dataset copy that you'll use to wrangle species mean data 
str(cens.sp)

# Drop species with fewer than 3 records 
cens.sp <- subset(cens.sp, with(cens.sp, species %in% names(which(table(species)>=3)))) 

# species mean summary - should be no NAs here 
cens.sp <- cens.sp %>% group_by(species) %>% summarise(hb = mean(hb),   
                                                  elev = mean(elev),  
                                                  mass = mean(mass),
                                                  wl = mean(wl),
                                                  mcv = mean(mcv),
                                                  mcv.log = mean(mcv.log),
                                                  trbc = mean(trbc),
                                                  mchc = mean(mchc)
                                                  ) 

# Standardize predictors 
cens.sp$mcv.z <- standardize(cens.sp$mcv)
cens.sp$trbc.z <- standardize(cens.sp$trbc)
cens.sp$mchc.z <- standardize(cens.sp$mchc)
cens.sp$mass.log <- log10(cens.sp$mass)

# This dataset now contains species mean values for Hb, TRBC, MCV for all species with 3 or more individuals sampled. 
```


# Pre-processing for single-species model sets 
```{r}
# Need to ID min number of indiv/species necessary to run models- 6? 10? 
# Subset from censdat, wich has NAs removed 
# Will need to run a standardized model *and* unstandardized model per species miniset (I think)
# BUT, if goal is "proportional contribution of TRBC relative to MCV in driving [Hb]", I think we want unstandardized...
# Remember that you have 2 functional groups for Patagona; will need to drop gigas_S if working up phylo signal
# Quick test w/ Sephanoides sephaniodes at 5 looks like too few 
# As a general rule, should be at least 10 observations per variable, so we'll use n=10 as our cutoff 
# Might consider doing as EBL did and making a big loop to run through the 30 species-specific models 

# Get dataset counts 
sp.count.cens <- censdat %>% group_by(species) %>% summarise(count = length(nk)) # 59 species in indiv-level models
# 48 species in species mean CeNS analysis 

# Make a species-specific modeling dataset
cens.ss <- subset(censdat, with(censdat, species %in% names(which(table(species)>=8)))) # was set at 10
ss.count.cens <- cens.ss %>% group_by(species) %>% summarise(count = length(nk)) # Obs/species for ss dataset

# Split data frame by species and dump into a massive list
cens.ss.list <- cens.ss %>% group_split(species)

# Now write individual data frames for input into models 
Amel <- as.data.frame(cens.ss.list[[1]]); str(Amel) # check structure on this first data frame to verify correct
Acas <- as.data.frame(cens.ss.list[[2]])
Akin <- as.data.frame(cens.ss.list[[3]])
Aama <- as.data.frame(cens.ss.list[[4]])
Clar <- as.data.frame(cens.ss.list[[5]])
Coen <- as.data.frame(cens.ss.list[[6]])
Ccoe <- as.data.frame(cens.ss.list[[7]])
Ciri <- as.data.frame(cens.ss.list[[8]])
Cvio <- as.data.frame(cens.ss.list[[9]])
Ccor <- as.data.frame(cens.ss.list[[10]])
Eluc <- as.data.frame(cens.ss.list[[11]])
Econ <- as.data.frame(cens.ss.list[[12]])
Fmel <- as.data.frame(cens.ss.list[[13]])
Ghir <- as.data.frame(cens.ss.list[[14]])
Hame <- as.data.frame(cens.ss.list[[15]])
Hmic <- as.data.frame(cens.ss.list[[16]])
Hlea <- as.data.frame(cens.ss.list[[17]])
Llaf <- as.data.frame(cens.ss.list[[18]])
Lnun <- as.data.frame(cens.ss.list[[19]])
Lvic <- as.data.frame(cens.ss.list[[20]])
Meup <- as.data.frame(cens.ss.list[[21]])
Mpho <- as.data.frame(cens.ss.list[[22]])
Mtyr <- as.data.frame(cens.ss.list[[23]])
Ound <- as.data.frame(cens.ss.list[[24]])
Oest <- as.data.frame(cens.ss.list[[25]])
Omel <- as.data.frame(cens.ss.list[[26]])
Pgign <- as.data.frame(cens.ss.list[[27]])
Pgigs <- as.data.frame(cens.ss.list[[28]])
Pguy <- as.data.frame(cens.ss.list[[29]])
Pmal <- as.data.frame(cens.ss.list[[30]])
Pcya <- as.data.frame(cens.ss.list[[31]])
Tfur <- as.data.frame(cens.ss.list[[32]])

# Pguy <- censdat[which(censdat$species == "Phaethornis_guy"),] # another clunky subset alternative

# Predictor dataset - take a look at distributions
#p <- ggpairs(subset(Ccoe, select = c(elev, hb, mcv, trbc, mcv.log, mcv.z, trbc.z, mchc))); print(p)
# 
# p <- (ggplot(Amel, aes(x=trbc)) + 
#        geom_density(alpha=.2, fill="#FF6666") +
#        geom_histogram(aes(y=..density..), colour="black", fill="white"))
#        # geom_vline(aes(xintercept=35), color="blue", linetype="dashed", size=1) + 
#        # geom_vline(aes(xintercept=75), color="blue", linetype="dashed", size=1)) 
# p
```


# Outlier assessment for single-species model sets 
Generally: We're taking a conservative approach and choosing to include all data we can, especially because these single-species datasets are so small. After initially running initial models with ALL data, we assessed model fit and diagnostic plots and then revisited conservative outlier elimination of single points per dataset. Specific notes below; most outliers eliminated due to wonky combinations of too low or too high MCV values for TRBC (and vice-versa), and weird combinations of these two with Hb (too high or too low). A couple points eliminated due to seemingly outlier Hb points that actually fall w/in normal Hb range, but that stood out due to low sample sizes (so removed these points to improve overall model fit). 
```{r}
# A. amazilia
qqPlot(Aama$trbc)
# Drop NK168931; Single outlier point: highest Hb value but low MCV and super high TRBC - high standard deviation 
Aama <- Aama[-which(Aama$nk == 168931),]

# C. violifer
qqPlot(Cvio$trbc)
# Drop NK168452; super high Hb at ~2,800 m but crazy low TRBC
Cvio <- Cvio[-which(Cvio$nk == 168452),]

# E. condamini
qqPlot(Econ$trbc)
# Drop NK220376; super high Hb and outlier on the MCV and TRBC axes
Econ <- Econ[-which(Econ$nk == 220376),]

# H. amethysticollis
# Tough call, "outlier" is NK163809 (low Hb, super high MCV, super low TRBC); skews distribution a bit but also likely 
# related to small sample size. Erring on the conservative side, leaving this point (esp since outliers have relatively)
# small effects on CeNS index)

# H. leadbeateri
# Drop NK161154; Hb of 21 at moderate elev, coupled w/ 2nd lowest MCV and highest TRBC
# That set of characteristics makes this point stand out 
Hlea <- Hlea[-which(Hlea$nk == 161154),]

# L. nuna
# Really on the fence about this one: NK159749
# Clear case of super high Hb but really not that high (22.0), coupled with normal-ish MCV and TRBC
# Basically: this is a low sample size outlier; if more samples, chance of seeing values closer to 22.9 Hb greater
# BUT, models fit better without this point. Doesn't have very strong effect on CeNS index, but removing for fit. 
Lnun <- Lnun[-which(Lnun$nk == 159749),]

# M. phoebe
# Drop NK162840; Low Hb (15.9) at high elev (~3700 m), coupled w/ low MCV and high TRBC for this species 
Mpho <- Mpho[-which(Mpho$nk == 162840),]

# O. underwoodii
# Drop NK167872; High Hb (22.2), highest MCV in species dataset + 3rd lowest TRBC for species dataset
# This could easily be an outlier due to low sampling, but we want models to fit well... 
Ound <- Ound[-which(Ound$nk == 167872),]

# Check distributions 
# p <- ggpairs(subset(test, select = c(elev, hb, mcv, trbc, mcv.log, mcv.z, trbc.z))); print(p)
```


Set global plot theme 
```{r}
# Set global plot theme
theme_set(theme_bw() +
            theme(
              plot.background = element_blank()
              ,panel.grid.major = element_blank()
              ,panel.grid.minor = element_blank()
              ,panel.background = element_blank()
              ,axis.text.x  = element_text(angle=90, vjust=0.5, size=8)
            ))
```





#### CeNS MODELING #####

Three broad model categories 
1) indiviual-level (il) dataset (all data from all individuals of all species; no elimination of sampling outliers)
2) species-mean (sm) dataset (drop species with < 3 individuals sampled, calculate species means, run models w/ this dataset)
3) single-species (ss) models for well-sampled species (figure out threshold min value of individuals needed to run these)
  --> Result from single-species models will form CeNS index


### 1) Individual-level CeNS models - What explains CeNS variation within species? 

# Set up and run models
We'll fit two models for our individual-level data: 
1) Intercept only null model
2) "Full" model hb ~ MCV + TRBC + (1|species)
The species grouping variable is essential to our model design because it will allow us to account for repeated sampling within species (i.e., will hold species identity constant) while estimating variation within species.

Note: on 5/13/21 I removed the intercept only + (1|species) model for ease of comparison in the two model format with the species mean dataset. 
```{r}
# INTERCEPT ONLY 
job::job({ # Send this to a job so you can use the console while it runs
cens.il.m1 <- brm(
  formula = bf(hb ~ 1),
  data = censdat,
  family = gaussian(), 
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000, 
  control = list(adapt_delta = 0.99, max_treedepth = 15),
  sample_prior = TRUE # save priors
)
save(cens.il.m1, file="cens.il.m1_InterceptOnly.RData") # save model
#load("cens.il.m1_InterceptOnly.RData") # If loading from pre-saved file and not re-running

# # INTERCEPT + SPECIES GROUPING VARIABLE 
# cens.il.m2 <- brm(
#   formula = bf(hb ~ 1 + (1|species)),
#   data = censdat,
#   family = gaussian(),
#   cores = 4,
#   chains = 4,
#   thin = 10,
#   warmup = 5000, # default is iter/2; shouldn't ever be larger than iter
#   iter = 10000, 
#   control = list(adapt_delta = 0.99, max_treedepth = 15),
#   sample_prior = TRUE # save priors
# )
# save(cens.il.m2, file="cens.il.m2_SpeciesREOnly.RData") # save model
#load("cens.il.m2_SpeciesREOnly.RData") 

# PREDICTORS AND SPECIES GROUPING VARIABLE 
cens.il.m2 <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z + (1|species)),
  data = censdat,
  family = gaussian(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15),
  sample_prior = TRUE # save priors
)
save(cens.il.m2, file="cens.il.m2_Predictors_SpeciesRE.RData") # save model
#load("cens.il.m2_Predictors_SpeciesRE.RData")
})
```


# Cens individual-level: Summarize and check fit 
Explanation of what mcmc_plot output below means: https://cran.r-project.org/web/packages/bayesplot/vignettes/plotting-mcmc-draws.html
```{r}
# FIT AND CONVERGENCE 
mcmc_plot(cens.il.m2, type = "trace") 
plot(cens.il.m2, N = 2, ask = FALSE)
bayesplot::pp_check(cens.il.m2, resp = "hb", nsamples = 200) # pull 100 draws from model and cast back to original data 
bayesplot::pp_check(cens.il.m2, type = "stat", stat = 'median', nsamples = 100)
bayesplot::pp_check(cens.il.m2, nsamples = 200, type = "stat_2d") + theme_bw(base_size = 20) # nice estimates
mcmc_plot(cens.il.m2, type = "acf_bar") # looks at autocorrelation
plot(conditional_effects(cens.il.m2), points = TRUE) # conditional effects 

# Quick plot of estimates and 95% CIs (default is 95% CI; adjust prob to get other CIs)
mcmc_plot(cens.il.m2)  

# Residual plots 
# typical residual plot but w/ addition of uncertainty associated w/ each residual given by generating draws from the dist 
# associated with each residual
censdat %>%
  add_residual_draws(cens.il.m2) %>%
  ggplot(aes(x = .row, y = .residual)) +
  stat_pointinterval()

censdat %>%
  add_predicted_draws(cens.il.m2) %>%
  summarise(
    p_residual = mean(.prediction < hb), # probability residual; Bayesian predictive p-value 
    z_residual = qnorm(p_residual) # quantile residuals 
  ) %>%
  ggplot(aes(sample = z_residual)) +
  geom_qq() +
  geom_abline()
# If predicted distribution is uniform, probabilities should be well calibrated
```


# Blood index: Plot outputs of posterior mean estimates and 95% credible intervals (full models, m1-m6)
```{r}
# Plot these nicely and without intercepts, which throws off scale: 
# Circle = point estimate (model summary, print(hb.m6))
# Thin bars = default 90% CI; adjust prob_outer=0.95 to get 95% CI 
# Thick bars = default 50% CI; adjust prob=0.50 to get anything else 
# x-axis should be scale based on value of estimates coming out of the model 

# Model 23 
#pairs(hb.m3)
color_scheme_set("viridisD") # nice default
cens.il.m2.p1 <- mcmc_plot(cens.il.m2, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "cens.il.m2: Individual-level Comparison") + 
scale_y_discrete(labels=c("MCV","TRBC"))  
cens.il.m2.p1
ggsave(cens.il.m2.p1, filename = "cens.il.m2.p1_PosteriorEstimates&CredibleIntervals_05-27-21.pdf", bg="transparent", height=7, width=9, units="in")

summary(cens.il.m2)
# Both MCV and TRBC have strong positive effects on Hb.
# As TRBC increases, Hb increases. As MCV increases, Hb increases.
# Effect of TRBC is marginally stronger than MCV (estimates: TRBC = 2.05; MCV = 1.92)
# So, it seems that individuals increase Hb by increasing TRBC. 
```


# Cens individual-level: Collate model summaries and WAIC scores 
```{r}
# Print model summaries 
sink("CeNS_IndividualLevel_brms_model_summaries.txt",append = TRUE)
summary(cens.il.m1, waic=TRUE)
summary(cens.il.m2, waic=TRUE)
sink()
# print(hb.test, prob=0.95) # change CI cut-off by adjusting prob; remember Bayesian default may not be 95%

# Get model WAIC scores  
il.m1.waic <- waic(cens.il.m1)
il.m2.waic <- waic(cens.il.m2)
cens.il.waics <- cbind(il.m1.waic, il.m2.waic); cens.il.waics
write.csv(cens.il.waics, "CeNS_IndividualLevel_brms_models_waics.csv") # totally unintelligible cumbersome doc w/ all pointwise comparisons 
```


# Cens - Individual level: Calculate Intraclass correlation coefficient (ICC) explained by species grouping variable 
Calculated from Burkner's phylo  brms tutorial: https://cran.r-project.org/web/packages/brms/vignettes/brms_phylogenetics.html
Note from Burkner: Note that the phylogenetic signal is just a synonym of the intra-class correlation (ICC) used in the context phylogenetic analysis.
```{R}
# CALCULATE INTRACLASS CORRELATION (ICC) EXPLAINED BY SPECIES GROUPING VARIABLE 
# ICC = Tells you proportion of total variance in response variable that is acccounted for by species identity (i.e. clustering)

# ICC for full model 
hyp.cens.il.m2 <- "sd_species__Intercept^2 / (sd_species__Intercept^2 + sigma^2) = 0"
(hyp.cens.il.m2 <- hypothesis(cens.il.m2, hyp.cens.il.m2, class = NULL))
plot(hyp.cens.il.m2)
# 14% variance explained; est = 0.14, CI = 0.06-0.23

#performance::variance_decomposition(cens.il.m2)
# Visually check how variance changes by adding in species term and examining plots 
# PPD1 <- posterior_predict(cens.il.m2, re.form =  ~ species)
# plot(PPD1)
```


# Cens individual-level: MODEL COMPARISON 
```{r}
# leave one out cross-validation, lowest is "best"
# if 2*standard error > delta LOOIC, models aren't necessarily distinguishable

library(loo)
sink("CeNS_IndividualLevel_brms_models_all_looic.txt", append=FALSE)
LOO(cens.il.m1, cens.il.m2, reloo=FALSE) 
sink()

# Calculate Bayesian R^2:
bayes_R2(cens.il.m1) 
#bayes_R2(cens.il.m2) # 0.17
bayes_R2(cens.il.m2) # 0.56

# Model comparisons:
#            elpd_diff se_diff
# cens.il.m2    0.0       0.0 
# cens.il.m1 -243.3      19.1  

# Now re-run top model with unstandardized predictors to estimate strength of relationship between Xs and y:
job::job({ # Send to a job to free up console
cens.il.m2.unstandardized <- 
  update(cens.il.m2,
        newdata = censdat,
        formula = hb ~ 1 + mcv + trbc + (1|species),
        chains = 4, cores = 4)
save(cens.il.m2.unstandardized, file="cens.il.m2.unstandardized_Predictors_SpeciesRE.RData") # save model
})
# load("cens.il.m2.unstandardized_Predictors_SpeciesRE.RData")

summary(cens.il.m2.unstandardized)
# mcv = 0.12; trbc = 1.81; what this tells us: 
# For every unit increase in TRBC, [Hb] increases by 1.81 g/dl
# For every unit increase in MCV, [Hb] increases by 0.12 g/dl
```

Quick summary of top model comparison: 
- Model 2, full model + species grouping variable fits best by var! Variance explained by species: 14%. R^2 = 0.56. 

Standardized Estimates: 
MCV = 1.92
TRBC = 2.05

Unstandardized Estimates: 
MCV = 0.12
TRBC = 1.81
- For every increase in MCV of one fl, we expect [Hb] will increase by 0.12 g/dl. 
- For every increase in TRBC of one unit, we expect [Hb] will increase by 1.81 g/dl. 
--> This suggests that TRBC is the primary way through which birds increase [Hb], not MCV. Perhaps this is explained by increasing Hb through erythropoesis, increased cells, consistent w/ acclimatization response? 
Also might suggest that TRBC increases happen faster than MCV increeases?? Not sure we learn about timing here. 



### 2) Species mean CeNS models - What explains CeNS variation over 22 million years of hummingbird evolution?

# Set up and run models
We'll fit two models for our species mean data: 
1) Intercept only null model
2) "Full" model hb ~ MCV + TRBC 
Note: don't model w/ mcv.log. While this does make distribution seemingly perfectly gaussian, this will throw off estimates tremendously because mcv.log is obviously on a log scale. Models are robust to the slightly-less-than-gaussian distributions of raw data, so leave these as is. 
```{r}
# INTERCEPT ONLY 
job::job({ # Send this to a job so you can use the console while it runs
cens.sm.m1 <- brm(
  formula = bf(hb ~ 1),
  data = cens.sp,
  family = gaussian(), 
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000, 
  control = list(adapt_delta = 0.99, max_treedepth = 15),
  sample_prior = TRUE # save priors
)
save(cens.sm.m1, file="cens.sm.m1_InterceptOnly.RData") # save model
# load("cens.sm.m1_InterceptOnly.RData") # If loading from pre-saved file and not re-running

# PREDICTORS 
cens.sm.m2 <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = cens.sp,
  family = gaussian(), # gaussian fits better than student 
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15),
  sample_prior = TRUE # save priors
)
save(cens.sm.m2, file="cens.sm.m2_Predictors_SpeciesRE.RData") # save model
#load("cens.sm.m2_Predictors_SpeciesRE.RData")
})
```


# Cens species mean: Summarize and check fit 
Explanation of what mcmc_plot output below means: https://cran.r-project.org/web/packages/bayesplot/vignettes/plotting-mcmc-draws.html
```{r}
# FIT AND CONVERGENCE 
mcmc_plot(cens.sm.m2, type = "trace") 
plot(cens.sm.m2, N = 2, ask = FALSE)
bayesplot::pp_check(cens.sm.m2, resp = "hb", nsamples = 200) # pull 100 draws from model and cast back to original data 
bayesplot::pp_check(cens.sm.m2, type = "stat", stat = 'median', nsamples = 100)
bayesplot::pp_check(cens.sm.m2, nsamples = 200, type = "stat_2d") + theme_bw(base_size = 20) # nice estimates
mcmc_plot(cens.sm.m2, type = "acf_bar") # looks at autocorrelation
plot(conditional_effects(cens.sm.m2), points = TRUE) # conditional effects 

# Quick plot of estimates and 95% CIs (default is 95% CI; adjust prob to get other CIs)
mcmc_plot(cens.sm.m2)  

# Residual plots 
# typical residual plot but w/ addition of uncertainty associated w/ each residual given by generating draws from the dist 
# associated with each residual
cens.sp %>%
  add_residual_draws(cens.sm.m2) %>%
  ggplot(aes(x = .row, y = .residual)) +
  stat_pointinterval()

cens.sp %>%
  add_predicted_draws(cens.sm.m2) %>%
  summarise(
    p_residual = mean(.prediction < hb), # probability residual; Bayesian predictive p-value 
    z_residual = qnorm(p_residual) # quantile residuals 
  ) %>%
  ggplot(aes(sample = z_residual)) +
  geom_qq() +
  geom_abline()
# If predicted distribution is uniform, probabilities should be well calibrated
```


# Blood index: Plot outputs of posterior mean estimates and 95% credible intervals (full models, m1-m6)
```{r}
# Plot these nicely and without intercepts, which throws off scale: 
# Circle = point estimate (model summary, print(hb.m6))
# Thin bars = default 90% CI; adjust prob_outer=0.95 to get 95% CI 
# Thick bars = default 50% CI; adjust prob=0.50 to get anything else 
# x-axis should be scale based on value of estimates coming out of the model 

# Model 3 
#pairs(hb.m3)
color_scheme_set("viridisD") # nice default
cens.sm.m2.p1 <- mcmc_plot(cens.sm.m2, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "cens.sm.m2: Posterior mean estimates & 95% Credible Intervals") + 
scale_y_discrete(labels=c("MCV","TRBC"))  
cens.sm.m2.p1
ggsave(cens.sm.m2.p1, filename = "cens.sm.m2.p1_PosteriorEstimates&CredibleIntervals_05-27-21.pdf", bg="transparent", height=7, width=9, units="in")

summary(cens.sm.m2)
# Both MCV and TRBC have strong positive effects on Hb.
# As TRBC increases, Hb increases. As MCV increases, Hb increases.
# Effect of TRBC is marginally stronger than MCV (estimates: TRBC = 1.45; MCV = 1.41)
# So, it seems that species increase Hb by increasing TRBC. 
```


# Cens species mean: Collate model summaries and WAIC scores 
```{r}
# Print model summaries 
sink("CeNS_SpeciesMean_brms_model_summaries.txt",append = TRUE)
summary(cens.sm.m1, waic=TRUE)
summary(cens.sm.m2, waic=TRUE)
sink()
# print(hb.test, prob=0.95) # change CI cut-off by adjusting prob; remember Bayesian default may not be 95%

# Get model WAIC scores  
sm.m1.waic <- waic(cens.sm.m1)
sm.m2.waic <- waic(cens.sm.m2)
cens.sm.waics <- cbind(sm.m1.waic, sm.m2.waic); cens.sm.waics
write.csv(cens.sm.waics, "CeNS_SpeciesMean_brms_models_waics.csv") # totally unintelligible cumbersome doc w/ all pointwise comparisons 
```


# Cens species mean: MODEL COMPARISON 
```{r}
# leave one out cross-validation, lowest is "best"
# if 2*standard error > delta LOOIC, models aren't necessarily distinguishable

library(loo)
sink("CeNS_SpeciesMean_brms_models_all_looic.txt", append=FALSE)
LOO(cens.sm.m1, cens.sm.m2, reloo=FALSE) 
sink()

# Calculate Bayesian R^2:
bayes_R2(cens.sm.m1) 
bayes_R2(cens.sm.m2) # 0.62

# Model comparisons:
#            elpd_diff se_diff
# cens.sm.m2   0.0       0.0  
# cens.sm.m1 -21.5       5.3      

# Now re-run top model with unstandardized predictors to estimate strength of relationship between Xs and y:
job::job({ # Send to a job to free up console
cens.sm.m2.unstandardized <- 
  update(cens.sm.m2,
        newdata = cens.sp,
        formula = hb ~ 1 + mcv + trbc,
        chains = 4, cores = 4)
save(cens.sm.m2.unstandardized, file="cens.sm.m2.unstandardized_Predictors_SpeciesRE.RData") # save model
})
# load("cens.sm.m2.unstandardized_Predictors_SpeciesRE.RData")

summary(cens.sm.m2.unstandardized)
# mcv = 0.14; trbc = 2.13; what this tells us: 
# For every unit increase in TRBC, [Hb] increases by 2.15 g/dl
# For every unit increase in MCV, [Hb] increases by 0.14 g/dl
```

Quick summary of top model comparison: 
- Model 2, full model fits best by var! R^2 = 0.62. 

Standardized Estimates: 
MCV = 1.41
TRBC = 1.45

Unstandardized Estimates: 
MCV = 0.14
TRBC = 2.15
- For every increase in MCV of one fl, we expect [Hb] will increase by 0.14 g/dl. 
- For every increase in TRBC of one unit, we expect [Hb] will increase by 2.15 g/dl. 


########


# 3) species-specific CeNS models and the CeNS index 

# Set up models...all currently in testing phase 
When datasets are large, priors are unlikely to have large influence unless they are highly informative.
Best description of the effect of priors I've seen (look at the  comparison plot at the end!): https://www.rensvandeschoot.com/tutorials/brms-priors/
TAKE HOME: Informative priors pull the posteriors towards them, while uninformarive priors yield a posterior that is centred around what would be the frequentist (LME4) estimate.
```{r}
# get priors
get_prior(hb ~ 1 + mcv + trbc, data = Pguy) 

# Futz w/ priors to get model to fit better 
# Overwrite those (not so) terrible choices with some slightly informed priors.
# Otherwise known as 'let the data drive the model'. 
# prior.Pguy <- c(set_prior("student_t(3, 18.9, 2.5)", class = "Intercept"), # Set intercept prior
#                 set_prior("student_t(3,100, 2.5", class = "b", coef="mcv"),
#                 set_prior("student_t(3,2, 2.5", class = "b", coef="trbc")) # Class b = all responses
# # 
# prior1 <- c(
# prior(normal(0, 10), class = Intercept),
# prior(normal(0, 10), class = b, coef = gender),
# prior(cauchy(0, 10), class = sigma)
# )
# 
# plot(hypothesis(cens.Pguy, "mcv > 0", alpha=0.05)) # see efffect of priors on posterior
# get_variables(cens.Pguy)
# summary(cens.Pguy)
```


# FIT MODELS 
IMPORTANT! Although we aren't doing model comparison, it is essential to use standardized predictors because otherwise the relationship between TRBC and MCV will always be heavily skewed towards TRBC (aka, it will always look like TRBC has a 1.5-2x larger effect than MCV). TRBC typically *does* have a larger effect than MCV, but the difference being that strong is partly attributable to non-standardized units. 

Must run models w/ standardized inputs; re-run if needing to estimate real-world estimates. 
```{r}
job::job({ # Send this to a job so you can use the console while it runs
  #Note that job() is kind of wonky, sometimes doesn't run properly, & sometimes produces errors/doesn't save right models

  cens.Amel <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Amel,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Amel, file="cens.Amel.RData") # save model

  cens.Acas <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Acas,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Acas, file="cens.Acas.RData") # save model

cens.Akin <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Akin,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Akin, file="cens.Akin.RData") # save model

cens.Aama <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Aama,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Aama, file="cens.Aama.RData") # save model

 cens.Clar <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Clar,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Clar, file="cens.Clar.RData") # save model

 cens.Coen <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Coen,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Coen, file="cens.Coen.RData") # save model

 cens.Ccoe <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Ccoe,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Ccoe, file="cens.Ccoe.RData") # save model

 cens.Ciri <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Ciri,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Ciri, file="cens.Ciri.RData") # save model

 cens.Cvio <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Cvio,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Cvio, file="cens.Cvio.RData") # save model

 cens.Ccor <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Ccor,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Ccor, file="cens.Ccor.RData") # save model

 cens.Eluc <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Eluc,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Eluc, file="cens.Eluc.RData") # save model

 cens.Econ <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Econ,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Econ, file="cens.Econ.RData") # save model

 cens.Fmel <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Fmel,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Fmel, file="cens.Fmel.RData") # save model

 cens.Ghir <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Ghir,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Ghir, file="cens.Ghir.RData") # save model

 cens.Hame <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Hame,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Hame, file="cens.Hame.RData") # save model

 cens.Hmic <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Hmic,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Hmic, file="cens.Hmic.RData") # save model

 cens.Hlea <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Hlea,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Hlea, file="cens.Hlea.RData") # save model

 cens.Llaf <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Llaf,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Llaf, file="cens.Llaf.RData") # save model

 cens.Lnun <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Lnun,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Lnun, file="cens.Lnun.RData") # save model

cens.Lvic <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Lvic,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Lvic, file="cens.Lvic.RData") # save model

 cens.Meup <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Meup,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Meup, file="cens.Meup.RData") # save model

 cens.Mpho <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Mpho,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Mpho, file="cens.Mpho.RData") # save model

 cens.Mtyr <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Mtyr,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Mtyr, file="cens.Mtyr.RData") # save model

 cens.Ound <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Ound,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Ound, file="cens.Ound.RData") # save model

 cens.Oest <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Oest,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Oest, file="cens.Oest.RData") # save model

 cens.Omel <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Omel,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Omel, file="cens.Omel.RData") # save model

# Patagona gigas N 
cens.Pgign <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Pgign,
  family = gaussian(), # student might fit a bit better than gaussian?
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Pgign, file="cens.Pgign.RData") # save model

# Patagona gigas S 
cens.Pgigs <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Pgigs,
  family = gaussian(), # student might fit a bit better than gaussian?
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Pgigs, file="cens.Pgigs.RData") # save model

# Phaethornis guy
  cens.Pguy <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Pguy,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Pguy, file="cens.Pguy.RData") # save model

# Phaethornis malaris
  cens.Pmal <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Pmal,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Pmal, file="cens.Pmal.RData") # save model

cens.Pcya <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Pcya,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Pcya, file="cens.Pcya.RData") # save model

# Thalurania furcata
  cens.Tfur <- brm(
  formula = bf(hb ~ 1 + mcv.z + trbc.z),
  data = Tfur,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.Tfur, file="cens.Tfur.RData") # save model

})
```


# IF YOU'VE ALREADY RUN MODELS, load in data to save time
Send to job - takes longer than I'd anticipate to load in data.
```{R}
job::job({
load("cens.Amel.RData")
load("cens.Acas.RData")
load("cens.Akin.RData")
load("cens.Aama.RData")
load("cens.Clar.RData")
load("cens.Coen.RData")
load("cens.Ccoe.RData")
load("cens.Ciri.RData")
load("cens.Cvio.RData")
load("cens.Ccor.RData")
load("cens.Eluc.RData")
load("cens.Econ.RData")
load("cens.Fmel.RData")
load("cens.Ghir.RData")
load("cens.Hame.RData")
load("cens.Hmic.RData")
load("cens.Hlea.RData")
load("cens.Llaf.RData")
load("cens.Lnun.RData")
load("cens.Lvic.RData")
load("cens.Meup.RData")
load("cens.Mpho.RData")
load("cens.Mtyr.RData")
load("cens.Ound.RData")
load("cens.Oest.RData")
load("cens.Omel.RData")
load("cens.Pgign.RData")
load("cens.Pgigs.RData")
load("cens.Pguy.RData")
load("cens.Pmal.RData")
load("cens.Pcya.RData")
load("cens.Tfur.RData")
})
```


# FIT AND CONVERGENCE 
```{R}
# Get effective sample sizes 
# This is esp important since we're dealing with small sample sizes. 
# Effective Sample (ESS) should be as large as possible; BUT, for most applications, ESS > 1,000 is sufficient for stable 
# estimates (Bürkner, 2017). ESS corresponds to the # indep samples with the same estimation power as the N autocorrelated
# samples. It's a measure of “how much indep info there is in autocorrelated chains” (Kruschke 2015, p182-3).
# bayestestR::effective_sample(cens.Pguy) 
# bayestestR::effective_sample(cens.Mtyr) 
# bayestestR::effective_sample(cens.Pgigs) 
# bayestestR::effective_sample(cens.Pgign) 
# JUST LOOK AT BULK AND TAIL ESS FROM MODEL OUTPUT! 

# Fit 
# All look ok - no divergences to plot, nothing red-flaggy
mcmc_plot(cens.Amel, type = "trace") 
plot(cens.Amel, N = 2, ask = FALSE)
mcmc_plot(cens.Amel, type = "acf_bar") 

mcmc_plot(cens.Acas, type = "trace") 
plot(cens.Acas, N = 2, ask = FALSE)
mcmc_plot(cens.Acas, type = "acf_bar")

mcmc_plot(cens.Akin, type = "trace") 
plot(cens.Akin, N = 2, ask = FALSE)
mcmc_plot(cens.Akin, type = "acf_bar")

mcmc_plot(cens.Aama, type = "trace") 
plot(cens.Aama, N = 2, ask = FALSE)
mcmc_plot(cens.Aama, type = "acf_bar")

mcmc_plot(cens.Clar, type = "trace") 
plot(cens.Clar, N = 2, ask = FALSE)
mcmc_plot(cens.Clar, type = "acf_bar")

mcmc_plot(cens.Coen, type = "trace") 
plot(cens.Coen, N = 2, ask = FALSE)
mcmc_plot(cens.Coen, type = "acf_bar")

mcmc_plot(cens.Ccoe, type = "trace") 
plot(cens.Ccoe, N = 2, ask = FALSE)
mcmc_plot(cens.Ccoe, type = "acf_bar")

mcmc_plot(cens.Ciri, type = "trace") 
plot(cens.Ciri, N = 2, ask = FALSE)
mcmc_plot(cens.Ciri, type = "acf_bar")

mcmc_plot(cens.Cvio, type = "trace") 
plot(cens.Cvio, N = 2, ask = FALSE)
mcmc_plot(cens.Cvio, type = "acf_bar")

mcmc_plot(cens.Ccor, type = "trace") 
plot(cens.Ccor, N = 2, ask = FALSE)
mcmc_plot(cens.Ccor, type = "acf_bar")

mcmc_plot(cens.Eluc, type = "trace") 
plot(cens.Eluc, N = 2, ask = FALSE)
mcmc_plot(cens.Eluc, type = "acf_bar")

mcmc_plot(cens.Econ, type = "trace") 
plot(cens.Econ, N = 2, ask = FALSE)
mcmc_plot(cens.Econ, type = "acf_bar")

mcmc_plot(cens.Fmel, type = "trace") 
plot(cens.Fmel, N = 2, ask = FALSE)
mcmc_plot(cens.Fmel, type = "acf_bar")

mcmc_plot(cens.Ghir, type = "trace") 
plot(cens.Ghir, N = 2, ask = FALSE)
mcmc_plot(cens.Ghir, type = "acf_bar")

mcmc_plot(cens.Hame, type = "trace") 
plot(cens.Hame, N = 2, ask = FALSE)
mcmc_plot(cens.Hame, type = "acf_bar")

mcmc_plot(cens.Hmic, type = "trace") 
plot(cens.Hmic, N = 2, ask = FALSE)
mcmc_plot(cens.Hmic, type = "acf_bar")

mcmc_plot(cens.Hlea, type = "trace") 
plot(cens.Clar, N = 2, ask = FALSE)
mcmc_plot(cens.Hlea, type = "acf_bar")

mcmc_plot(cens.Llaf, type = "trace") 
plot(cens.Llaf, N = 2, ask = FALSE)
mcmc_plot(cens.Llaf, type = "acf_bar")

mcmc_plot(cens.Lnun, type = "trace") 
plot(cens.Lnun, N = 2, ask = FALSE)
mcmc_plot(cens.Lnun, type = "acf_bar")

mcmc_plot(cens.Lvic, type = "trace") 
plot(cens.Lvic, N = 2, ask = FALSE)
mcmc_plot(cens.Lvic, type = "acf_bar")

mcmc_plot(cens.Meup, type = "trace") 
plot(cens.Meup, N = 2, ask = FALSE)
mcmc_plot(cens.Meup, type = "acf_bar")

mcmc_plot(cens.Mpho, type = "trace") 
plot(cens.Mpho, N = 2, ask = FALSE)
mcmc_plot(cens.Mpho, type = "acf_bar")

mcmc_plot(cens.Mtyr, type = "trace") 
plot(cens.Mtyr, N = 2, ask = FALSE)
mcmc_plot(cens.Mtyr, type = "acf_bar")

mcmc_plot(cens.Ound, type = "trace") 
plot(cens.Ound, N = 2, ask = FALSE)
mcmc_plot(cens.Ound, type = "acf_bar")

mcmc_plot(cens.Oest, type = "trace") 
plot(cens.Oest, N = 2, ask = FALSE)
mcmc_plot(cens.Oest, type = "acf_bar")

mcmc_plot(cens.Omel, type = "trace") 
plot(cens.Omel, N = 2, ask = FALSE)
mcmc_plot(cens.Omel, type = "acf_bar")

mcmc_plot(cens.Pgign, type = "trace") 
plot(cens.Pgign, N = 2, ask = FALSE)
mcmc_plot(cens.Pgign, type = "acf_bar")

mcmc_plot(cens.Pgigs, type = "trace") 
plot(cens.Pgigs, N = 2, ask = FALSE)
mcmc_plot(cens.Pgigs, type = "acf_bar")

mcmc_plot(cens.Pguy, type = "trace") 
plot(cens.Pguy, N = 2, ask = FALSE)
mcmc_plot(cens.Pguy, type = "acf_bar")

mcmc_plot(cens.Pmal, type = "trace") 
plot(cens.Pmal, N = 2, ask = FALSE)
mcmc_plot(cens.Pmal, type = "acf_bar")

mcmc_plot(cens.Pcya, type = "trace") 
plot(cens.Pcya, N = 2, ask = FALSE)
mcmc_plot(cens.Pcya, type = "acf_bar")

mcmc_plot(cens.Tfur, type = "trace") 
plot(cens.Tfur, N = 2, ask = FALSE)
mcmc_plot(cens.Tfur, type = "acf_bar")


# Posterior predictive checks 
# standardizing variables also has the effect of fixing sampling outliers a bit better
color_scheme_set("blue") # nice default
bayesplot::pp_check(cens.Amel, resp = "hb", nsamples = 200)
bayesplot::pp_check(cens.Amel, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)

bayesplot::pp_check(cens.Acas, resp = "hb", nsamples = 200)
bayesplot::pp_check(cens.Acas, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)

bayesplot::pp_check(cens.Akin, resp = "hb", nsamples = 200)
bayesplot::pp_check(cens.Akin, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)

bayesplot::pp_check(cens.Aama, resp = "hb", nsamples = 200)
bayesplot::pp_check(cens.Aama, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)

bayesplot::pp_check(cens.Clar, resp = "hb", nsamples = 200) # slightly weird at the top
bayesplot::pp_check(cens.Clar, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)

bayesplot::pp_check(cens.Coen, resp = "hb", nsamples = 200)
bayesplot::pp_check(cens.Coen, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)

bayesplot::pp_check(cens.Ccoe, resp = "hb", nsamples = 200)
bayesplot::pp_check(cens.Ccoe, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)

bayesplot::pp_check(cens.Ciri, resp = "hb", nsamples = 200)
bayesplot::pp_check(cens.Ciri, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)

bayesplot::pp_check(cens.Cvio, resp = "hb", nsamples = 200)
bayesplot::pp_check(cens.Cvio, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)
bayesplot::pp_check(cens.Cvio, type = "scatter_avg")

bayesplot::pp_check(cens.Ccor, resp = "hb", nsamples = 200) # fits really nicely
bayesplot::pp_check(cens.Ccor, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)

bayesplot::pp_check(cens.Eluc, resp = "hb", nsamples = 200)
bayesplot::pp_check(cens.Eluc, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)

bayesplot::pp_check(cens.Econ, resp = "hb", nsamples = 200)
bayesplot::pp_check(cens.Econ, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)
bayesplot::pp_check(cens.Econ, type = "scatter_avg")

bayesplot::pp_check(cens.Fmel, resp = "hb", nsamples = 200) # hmm
bayesplot::pp_check(cens.Fmel, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)

bayesplot::pp_check(cens.Ghir, resp = "hb", nsamples = 200)
bayesplot::pp_check(cens.Ghir, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)

bayesplot::pp_check(cens.Hame, resp = "hb", nsamples = 200)
bayesplot::pp_check(cens.Hame, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)
bayesplot::pp_check(cens.Hame, type = "scatter_avg")

bayesplot::pp_check(cens.Hmic, resp = "hb", nsamples = 200)
bayesplot::pp_check(cens.Hmic, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)

bayesplot::pp_check(cens.Hlea, resp = "hb", nsamples = 200)
bayesplot::pp_check(cens.Hlea, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)
bayesplot::pp_check(cens.Hlea, type = "scatter_avg")

bayesplot::pp_check(cens.Llaf, resp = "hb", nsamples = 200)
bayesplot::pp_check(cens.Llaf, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)

bayesplot::pp_check(cens.Lnun, resp = "hb", nsamples = 200) # less than ideal due to n=10
bayesplot::pp_check(cens.Lnun, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)

bayesplot::pp_check(cens.Lvic, resp = "hb", nsamples = 200) # less than ideal due to n=10
bayesplot::pp_check(cens.Lvic, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)

bayesplot::pp_check(cens.Meup, resp = "hb", nsamples = 200)
bayesplot::pp_check(cens.Meup, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)
# stat_2d suggests one outlier; examining distribution doesn't highlight any obvious distributional outliers
# likely related to n=10 sample size; CIs overlap zero anyways; conservatively leaving all data. 

bayesplot::pp_check(cens.Mpho, resp = "hb", nsamples = 200)
bayesplot::pp_check(cens.Mpho, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)

bayesplot::pp_check(cens.Mtyr, resp = "hb", nsamples = 200) 
bayesplot::pp_check(cens.Mtyr, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)

bayesplot::pp_check(cens.Ound, resp = "hb", nsamples = 200)
bayesplot::pp_check(cens.Ound, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)

bayesplot::pp_check(cens.Oest, resp = "hb", nsamples = 200)
bayesplot::pp_check(cens.Oest, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)
# Two outlier-ish points, but appear to be related to low sample size (i.e., a couple outliery points); leaving

bayesplot::pp_check(cens.Omel, resp = "hb", nsamples = 200)
bayesplot::pp_check(cens.Omel, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)

bayesplot::pp_check(cens.Pgign, resp = "hb", nsamples = 200) 
bayesplot::pp_check(cens.Pgign, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)
bayesplot::pp_check(cens.Pgign, type = "scatter_avg")

bayesplot::pp_check(cens.Pgigs, resp = "hb", nsamples = 200)
bayesplot::pp_check(cens.Pgigs, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)

bayesplot::pp_check(cens.Pguy, resp = "hb", nsamples = 200)  
bayesplot::pp_check(cens.Pguy, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20) # or stat = "median"

bayesplot::pp_check(cens.Pmal, resp = "hb", nsamples = 200)  
bayesplot::pp_check(cens.Pmal, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20) # or stat = "median"

bayesplot::pp_check(cens.Pcya, resp = "hb", nsamples = 200) # less than ideal due to n=10
bayesplot::pp_check(cens.Pcya, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20)

bayesplot::pp_check(cens.Tfur, resp = "hb", nsamples = 200)  
bayesplot::pp_check(cens.Tfur, nsamples = 100, type = "stat_2d") + theme_bw(base_size = 20) # or stat = "median"

# Estimates 
#plot(conditional_effects(cens.Pguy), points = TRUE) # conditional effects 
# mcmc_plot(cens.Pguy)  
```


# Residual plots (sub in the dataset of interest)
```{r}
# Residual plots 
# typical residual plot but w/ addition of uncertainty associated w/ each residual given by generating draws from the dist 
# associated with each residual
Hame %>%
  add_residual_draws(cens.Hame) %>%
  ggplot(aes(x = .row, y = .residual)) +
  stat_pointinterval()

Hame %>%
  add_predicted_draws(cens.Hame) %>%
  summarise(
    p_residual = mean(.prediction < hb), # probability residual; Bayesian predictive p-value 
    z_residual = qnorm(p_residual) # quantile residuals 
  ) %>%
  ggplot(aes(sample = z_residual)) +
  geom_qq() +
  geom_abline()
# If predicted distribution is uniform, probabilities should be well calibrated

Mtyr %>%
  add_residual_draws(cens.Mtyr) %>%
  ggplot(aes(x = .row, y = .residual)) +
  stat_pointinterval()

Mtyr %>%
  add_predicted_draws(cens.Mtyr) %>%
  summarise(
    p_residual = mean(.prediction < hb), # probability residual; Bayesian predictive p-value 
    z_residual = qnorm(p_residual) # quantile residuals 
  ) %>%
  ggplot(aes(sample = z_residual)) +
  geom_qq() +
  geom_abline()

# pgig s
Pgigs %>%
  add_residual_draws(cens.Pgigs) %>%
  ggplot(aes(x = .row, y = .residual)) +
  stat_pointinterval()

Pgigs %>%
  add_predicted_draws(cens.Pgigs) %>%
  summarise(
    p_residual = mean(.prediction < hb), # probability residual; Bayesian predictive p-value 
    z_residual = qnorm(p_residual) # quantile residuals 
  ) %>%
  ggplot(aes(sample = z_residual)) +
  geom_qq() +
  geom_abline()

# pgig n
Pgign %>%
  add_residual_draws(cens.Pgign) %>%
  ggplot(aes(x = .row, y = .residual)) +
  stat_pointinterval()

Pgign %>%
  add_predicted_draws(cens.Pgign) %>%
  summarise(
    p_residual = mean(.prediction < hb), # probability residual; Bayesian predictive p-value 
    z_residual = qnorm(p_residual) # quantile residuals 
  ) %>%
  ggplot(aes(sample = z_residual)) +
  geom_qq() +
  geom_abline()
```


# Species-specific Conditional effects plots 
```{r}
# Color options: 'arg' should be one of “blue”, “brightblue”, “darkgray”, “gray”, “green”, “orange”, “pink”, “purple”, “red”, “teal”, “yellow”, “viridis”, “viridisA”, “viridisB”, “viridisC”, “viridisD”, “viridisE”
# color_scheme_set("blue") # nice default

# I tried setting these to all the same x-axis limits but it looked weird; looks much better to have each species plot
# with the axes that look best for it. 

color_scheme_set("viridisD")

cens.Amel.p1 <- mcmc_plot(cens.Amel, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "A. melanogenys") + 
# xlim(0, 8) + # Set axis limits 
# geom_vline(xintercept = 0) + # Horizontal line where data crosses 0 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left 
cens.Amel.p1
ggsave(cens.Amel.p1, filename = "cens.Amel.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Acas.p1 <- mcmc_plot(cens.Acas, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "A. castelnaudii") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left 
cens.Acas.p1
ggsave(cens.Acas.p1, filename = "cens.Acas.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Akin.p1 <- mcmc_plot(cens.Akin, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "A. kingii") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left 
cens.Akin.p1
ggsave(cens.Akin.p1, filename = "cens.Akin.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Aama.p1 <- mcmc_plot(cens.Aama, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "A. amazilia") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left 
cens.Aama.p1
ggsave(cens.Aama.p1, filename = "cens.Aama.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Clar.p1 <- mcmc_plot(cens.Clar, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "C. largipennis") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left   
cens.Clar.p1
ggsave(cens.Clar.p1, filename = "cens.Clar.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Coen.p1 <- mcmc_plot(cens.Coen, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "C. oenone") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left 
cens.Coen.p1
ggsave(cens.Coen.p1, filename = "cens.Coen.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Ccoe.p1 <- mcmc_plot(cens.Ccoe, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "C. coeligena") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left 
cens.Ccoe.p1
ggsave(cens.Ccoe.p1, filename = "cens.Ccoe.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Ciri.p1 <- mcmc_plot(cens.Ciri, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "C. iris") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left 
cens.Ciri.p1
ggsave(cens.Ciri.p1, filename = "cens.Ciri.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Cvio.p1 <- mcmc_plot(cens.Cvio, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "C. violifer") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left  
cens.Cvio.p1
ggsave(cens.Cvio.p1, filename = "cens.Cvio.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Ccor.p1 <- mcmc_plot(cens.Ccor, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "C. coruscans") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left  
cens.Ccor.p1
ggsave(cens.Ccor.p1, filename = "cens.Ccor.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Eluc.p1 <- mcmc_plot(cens.Eluc, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "C. luciani") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left 
cens.Eluc.p1
ggsave(cens.Eluc.p1, filename = "cens.Eluc.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Econ.p1 <- mcmc_plot(cens.Econ, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "C. condamini") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left   
cens.Econ.p1
ggsave(cens.Econ.p1, filename = "cens.Econ.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Fmel.p1 <- mcmc_plot(cens.Fmel, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "F. mellivora") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left 
cens.Fmel.p1
ggsave(cens.Fmel.p1, filename = "cens.Fmel.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Ghir.p1 <- mcmc_plot(cens.Ghir, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "G. hirsutus") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left 
cens.Ghir.p1
ggsave(cens.Ghir.p1, filename = "cens.Ghir.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Hame.p1 <- mcmc_plot(cens.Hame, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "H. amethysticollis") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left 
cens.Hame.p1
ggsave(cens.Hame.p1, filename = "cens.Hame.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Hmic.p1 <- mcmc_plot(cens.Hmic, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "H. micrastur") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left  
cens.Hmic.p1
ggsave(cens.Hmic.p1, filename = "cens.Hmic.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Hlea.p1 <- mcmc_plot(cens.Hlea, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "H. leadbeateri") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left 
cens.Hlea.p1
ggsave(cens.Hlea.p1, filename = "cens.Hlea.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Llaf.p1 <- mcmc_plot(cens.Llaf, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "L. lafresnayi") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left 
cens.Llaf.p1
ggsave(cens.Llaf.p1, filename = "cens.Llaf.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Lnun.p1 <- mcmc_plot(cens.Lnun, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "L. nuna") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left 
cens.Lnun.p1
ggsave(cens.Lnun.p1, filename = "cens.Lnun.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Lvic.p1 <- mcmc_plot(cens.Lvic, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "L. victoriae") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left 
cens.Lvic.p1
ggsave(cens.Lvic.p1, filename = "cens.Lvic.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Meup.p1 <- mcmc_plot(cens.Meup, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "M. eupogon") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left 
cens.Meup.p1
ggsave(cens.Meup.p1, filename = "cens.Meup.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Mpho.p1 <- mcmc_plot(cens.Mpho, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "M. phoebe") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left  
cens.Mpho.p1
ggsave(cens.Mpho.p1, filename = "cens.Mpho.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Mtyr.p1 <- mcmc_plot(cens.Mtyr, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "M. tyrianthina") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left 
cens.Mtyr.p1
ggsave(cens.Mtyr.p1, filename = "cens.Mtyr.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Ound.p1 <- mcmc_plot(cens.Ound, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "O. underwoodii") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left 
cens.Ound.p1
ggsave(cens.Ound.p1, filename = "cens.Ound.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Oest.p1 <- mcmc_plot(cens.Oest, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "O. estella") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left  
cens.Oest.p1
ggsave(cens.Oest.p1, filename = "cens.Oest.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Omel.p1 <- mcmc_plot(cens.Omel, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "O. melanogaster") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left 
cens.Omel.p1
ggsave(cens.Omel.p1, filename = "cens.Omel.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

# Pgign
cens.Pgign.p1 <- mcmc_plot(cens.Pgign, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "P. gigas (North)") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left 
cens.Pgign.p1
ggsave(cens.Pgign.p1, filename = "cens.Pgign.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

# Pgig s
cens.Pgigs.p1 <- mcmc_plot(cens.Pgigs, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "P. gigas (South)") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left  
cens.Pgigs.p1
ggsave(cens.Pgigs.p1, filename = "cens.Pgigs.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Pguy.p1 <- mcmc_plot(cens.Pguy, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "P. guy") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left  
cens.Pguy.p1
ggsave(cens.Pguy.p1, filename = "cens.Pguy.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Pmal.p1 <- mcmc_plot(cens.Pmal, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "P. malaris") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left 
cens.Pmal.p1
ggsave(cens.Pmal.p1, filename = "cens.Pmal.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Pcya.p1 <- mcmc_plot(cens.Pcya, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "P. cyanopterus") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left 
cens.Pcya.p1
ggsave(cens.Pcya.p1, filename = "cens.Pcya.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

cens.Tfur.p1 <- mcmc_plot(cens.Tfur, pars=c("b_mcv.z", "b_trbc.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on [Hb]", title = "T. furcata") + 
scale_y_discrete(labels=c("MCV","TRBC")) +
            theme(plot.title = element_text(family = "Helvetica", color="black",size=12)) + # font = panel header size
            theme(text = element_text(family="Helvetica",size=9)) # y axis labels
            # ggtitle("A") + # Assign panel number/header
            # theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
            # plot.title = element_text(face="bold"))  # This makes panel header bold 
            # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
            #theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left 
cens.Tfur.p1
ggsave(cens.Tfur.p1, filename = "cens.Tfur.p1_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")

# PLOT ALL SPECIES-SPECIFIC OUTPUTS TOGETHER 
library(patchwork)
# Alternative layout option = BETTER, USE THIS ONE:
SS_PosteriorProbs <- (cens.Amel.p1 + cens.Acas.p1 + cens.Akin.p1 + cens.Aama.p1 + cens.Clar.p1 + cens.Coen.p1 + 
                      cens.Ccoe.p1 + cens.Ciri.p1 + cens.Cvio.p1 + cens.Ccor.p1 + cens.Eluc.p1 + cens.Econ.p1 + 
                      cens.Fmel.p1 + cens.Ghir.p1 + cens.Hame.p1 + cens.Hmic.p1 + cens.Hlea.p1 + cens.Llaf.p1 + 
                      cens.Lnun.p1 + cens.Lvic.p1 + cens.Meup.p1 + cens.Mpho.p1 + cens.Mtyr.p1 + cens.Ound.p1 +   
                      cens.Oest.p1 + cens.Omel.p1 + cens.Pgign.p1 + cens.Pgigs.p1 + cens.Pguy.p1 + cens.Pmal.p1 + 
                      cens.Pcya.p1 + cens.Tfur.p1 +
                      plot_layout(guides = "collect"))
plot(SS_PosteriorProbs)
ggsave(SS_PosteriorProbs, filename = "CeNS_Species-Specific_PosteriorProbs_06-02-21.pdf", bg="transparent", height=7, width=12, units="in")
```

JESSIE NOTE: Ideally need to figure out how to get horizontal lines at zero on all plots as an x-axis marker (or set axes to all scame scale)


# Bayes R^2 and model summaries  
```{r}
# R^2 values 
cens.R2 <- as.vector(c(
bayes_R2(cens.Amel)[1], # 0.51
bayes_R2(cens.Acas)[1], # 0.43
bayes_R2(cens.Akin)[1], # 0.42
bayes_R2(cens.Aama)[1], # 0.70
bayes_R2(cens.Clar)[1], # 0.60
bayes_R2(cens.Coen)[1], # 0.62
bayes_R2(cens.Ccoe)[1], # 0.26
bayes_R2(cens.Ciri)[1], # 0.27
bayes_R2(cens.Cvio)[1], # 0.34
bayes_R2(cens.Ccor)[1], # 0.37
bayes_R2(cens.Eluc)[1], # 0.54
bayes_R2(cens.Econ)[1], # 0.39
bayes_R2(cens.Fmel)[1], # 0.94
bayes_R2(cens.Ghir)[1], # 0.84
bayes_R2(cens.Hame)[1], # 0.35
bayes_R2(cens.Hmic)[1], # 0.38
bayes_R2(cens.Hlea)[1], # 0.41
bayes_R2(cens.Llaf)[1], # 0.41
bayes_R2(cens.Lnun)[1], # 0.39
bayes_R2(cens.Lvic)[1], # 0.68
bayes_R2(cens.Meup)[1], # 0.29
bayes_R2(cens.Mpho)[1], # 0.55
bayes_R2(cens.Mtyr)[1], # 0.28
bayes_R2(cens.Ound)[1], # 0.60
bayes_R2(cens.Oest)[1], # 0.56
bayes_R2(cens.Omel)[1], # 0.42
bayes_R2(cens.Pgign)[1], # 0.68
bayes_R2(cens.Pgigs)[1], # 0.29
bayes_R2(cens.Pguy)[1], # 0.65
bayes_R2(cens.Pmal)[1], # 0.75
bayes_R2(cens.Pcya)[1], # 0.49
bayes_R2(cens.Tfur)[1]# 0.82
))
cens.R2
length(cens.R2)
```


# CeNS Index
An index to evaluate the proportional contribution of TRBC relative to MCV in driving [Hb]
A 0-1 index, calculated as *TRBC/(MCV+TRBC)*
```{r}
# Calculate vector of cens (standardized) TRBC model estimates: 
cens.trbc <- as.vector(c(
fixef(cens.Amel)[3], fixef(cens.Acas)[3], fixef(cens.Akin)[3], 
fixef(cens.Aama)[3], fixef(cens.Clar)[3], fixef(cens.Coen)[3], 
fixef(cens.Ccoe)[3], fixef(cens.Ciri)[3], fixef(cens.Cvio)[3], 
fixef(cens.Ccor)[3], fixef(cens.Eluc)[3], fixef(cens.Econ)[3], 
fixef(cens.Fmel)[3], fixef(cens.Ghir)[3], fixef(cens.Hame)[3], 
fixef(cens.Hmic)[3], fixef(cens.Hlea)[3], fixef(cens.Llaf)[3], 
fixef(cens.Lnun)[3], fixef(cens.Lvic)[3], fixef(cens.Meup)[3], 
fixef(cens.Mpho)[3], fixef(cens.Mtyr)[3], fixef(cens.Ound)[3], 
fixef(cens.Oest)[3], fixef(cens.Omel)[3], fixef(cens.Pgign)[3], 
fixef(cens.Pgigs)[3], fixef(cens.Pguy)[3], fixef(cens.Pmal)[3], 
fixef(cens.Pcya)[3], fixef(cens.Tfur)[3]
)) 
cens.trbc
length(cens.trbc)

# Calculate vector of cens (standardized) MCV model estimates: 
cens.mcv <- as.vector(c(
fixef(cens.Amel)[2], fixef(cens.Acas)[2], fixef(cens.Akin)[2], 
fixef(cens.Aama)[2], fixef(cens.Clar)[2], fixef(cens.Coen)[2], 
fixef(cens.Ccoe)[2], fixef(cens.Ciri)[2], fixef(cens.Cvio)[2], 
fixef(cens.Ccor)[2], fixef(cens.Eluc)[2], fixef(cens.Econ)[2], 
fixef(cens.Fmel)[2], fixef(cens.Ghir)[2], fixef(cens.Hame)[2], 
fixef(cens.Hmic)[2], fixef(cens.Hlea)[2], fixef(cens.Llaf)[2], 
fixef(cens.Lnun)[2], fixef(cens.Lvic)[3], fixef(cens.Meup)[2], 
fixef(cens.Mpho)[2], fixef(cens.Mtyr)[2], fixef(cens.Ound)[2], 
fixef(cens.Oest)[2], fixef(cens.Omel)[2], fixef(cens.Pgign)[2], 
fixef(cens.Pgigs)[2], fixef(cens.Pguy)[2], fixef(cens.Pmal)[2], 
fixef(cens.Pcya)[3], fixef(cens.Tfur)[2]
)) 
cens.mcv
length(cens.mcv)
```


# CALCULATE UNSTANDARDIZED CENS COEFFICIENTS FOR REAL-WORLD ESTIMATES 
Trying to isolate whether variation in CeNS index is caused by sensitivity or variation...see notes from meeting with Chris. First step is to get estimates from unstandardized models and to plot these against CeNS coefficients. 
```{r}
job::job({ # Send this to a job so you can use the console while it runs
  #Note that job() is kind of wonky, sometimes doesn't run properly, & sometimes produces errors/doesn't save right models

  cens.unst.Amel <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Amel,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Amel, file="cens.unst.Amel.RData") # save model

  cens.unst.Acas <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Acas,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Acas, file="cens.unst.Acas.RData") # save model

cens.unst.Akin <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Akin,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Akin, file="cens.unst.Akin.RData") # save model

cens.unst.Aama <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Aama,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Aama, file="cens.unst.Aama.RData") # save model

 cens.unst.Clar <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Clar,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Clar, file="cens.unst.Clar.RData") # save model

 cens.unst.Coen <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Coen,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Coen, file="cens.unst.Coen.RData") # save model

 cens.unst.Ccoe <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Ccoe,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Ccoe, file="cens.unst.Ccoe.RData") # save model

 cens.unst.Ciri <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Ciri,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Ciri, file="cens.unst.Ciri.RData") # save model

 cens.unst.Cvio <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Cvio,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Cvio, file="cens.unst.Cvio.RData") # save model

 cens.unst.Ccor <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Ccor,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Ccor, file="cens.unst.Ccor.RData") # save model

 cens.unst.Eluc <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Eluc,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Eluc, file="cens.unst.Eluc.RData") # save model

 cens.unst.Econ <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Econ,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Econ, file="cens.unst.Econ.RData") # save model

 cens.unst.Fmel <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Fmel,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Fmel, file="cens.unst.Fmel.RData") # save model

 cens.unst.Ghir <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Ghir,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Ghir, file="cens.unst.Ghir.RData") # save model

 cens.unst.Hame <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Hame,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Hame, file="cens.unst.Hame.RData") # save model

 cens.unst.Hmic <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Hmic,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Hmic, file="cens.unst.Hmic.RData") # save model

 cens.unst.Hlea <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Hlea,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Hlea, file="cens.unst.Hlea.RData") # save model

 cens.unst.Llaf <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Llaf,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Llaf, file="cens.unst.Llaf.RData") # save model

 cens.unst.Lnun <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Lnun,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Lnun, file="cens.unst.Lnun.RData") # save model

cens.unst.Lvic <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Lvic,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Lvic, file="cens.unst.Lvic.RData") # save model

 cens.unst.Meup <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Meup,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Meup, file="cens.unst.Meup.RData") # save model

 cens.unst.Mpho <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Mpho,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Mpho, file="cens.unst.Mpho.RData") # save model

 cens.unst.Mtyr <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Mtyr,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Mtyr, file="cens.unst.Mtyr.RData") # save model

 cens.unst.Ound <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Ound,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Ound, file="cens.unst.Ound.RData") # save model

 cens.unst.Oest <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Oest,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Oest, file="cens.unst.Oest.RData") # save model

 cens.unst.Omel <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Omel,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Omel, file="cens.unst.Omel.RData") # save model

# Patagona gigas N 
cens.unst.Pgign <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Pgign,
  family = gaussian(), # student might fit a bit better than gaussian?
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Pgign, file="cens.unst.Pgign.RData") # save model

# Patagona gigas S 
cens.unst.Pgigs <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Pgigs,
  family = gaussian(), # student might fit a bit better than gaussian?
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Pgigs, file="cens.unst.Pgigs.RData") # save model

# Phaethornis guy
  cens.unst.Pguy <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Pguy,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Pguy, file="cens.unst.Pguy.RData") # save model

# Phaethornis malaris
  cens.unst.Pmal <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Pmal,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Pmal, file="cens.unst.Pmal.RData") # save model

cens.unst.Pcya <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Pcya,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Pcya, file="cens.unst.Pcya.RData") # save model

# Thalurania furcata
  cens.unst.Tfur <- brm(
  formula = bf(hb ~ 1 + mcv + trbc),
  data = Tfur,
  family = student(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15), # adapt_delta can be between 0.8-1.0; higher helps convergence
  sample_prior = TRUE # save priors
)
save(cens.unst.Tfur, file="cens.unst.Tfur.RData") # save model

})
```


# IF YOU'VE ALREADY RUN MODELS, load in data to save time
Send to job - takes longer than I'd anticipate to load in data.
```{R}
job::job({
load("cens.unst.Amel.RData")
load("cens.unst.Acas.RData")
load("cens.unst.Akin.RData")
load("cens.unst.Aama.RData")
load("cens.unst.Clar.RData")
load("cens.unst.Coen.RData")
load("cens.unst.Ccoe.RData")
load("cens.unst.Ciri.RData")
load("cens.unst.Cvio.RData")
load("cens.unst.Ccor.RData")
load("cens.unst.Eluc.RData")
load("cens.unst.Econ.RData")
load("cens.unst.Fmel.RData")
load("cens.unst.Ghir.RData")
load("cens.unst.Hame.RData")
load("cens.unst.Hmic.RData")
load("cens.unst.Hlea.RData")
load("cens.unst.Llaf.RData")
load("cens.unst.Lnun.RData")
load("cens.unst.Lvic.RData")
load("cens.unst.Meup.RData")
load("cens.unst.Mpho.RData")
load("cens.unst.Mtyr.RData")
load("cens.unst.Ound.RData")
load("cens.unst.Oest.RData")
load("cens.unst.Omel.RData")
load("cens.unst.Pgign.RData")
load("cens.unst.Pgigs.RData")
load("cens.unst.Pguy.RData")
load("cens.unst.Pmal.RData")
load("cens.unst.Pcya.RData")
load("cens.unst.Tfur.RData")
})
```


# Make vectors of unstandardized coefficient estimates 
Used to assess possible correlation between CeNS index and other stuff 
```{r}
# Calculate vector of cens (standardized) TRBC model estimates: 
cens.unst.trbc <- as.vector(c(
fixef(cens.unst.Amel)[3], fixef(cens.unst.Acas)[3], fixef(cens.unst.Akin)[3], 
fixef(cens.unst.Aama)[3], fixef(cens.unst.Clar)[3], fixef(cens.unst.Coen)[3], 
fixef(cens.unst.Ccoe)[3], fixef(cens.unst.Ciri)[3], fixef(cens.unst.Cvio)[3], 
fixef(cens.unst.Ccor)[3], fixef(cens.unst.Eluc)[3], fixef(cens.unst.Econ)[3], 
fixef(cens.unst.Fmel)[3], fixef(cens.unst.Ghir)[3], fixef(cens.unst.Hame)[3], 
fixef(cens.unst.Hmic)[3], fixef(cens.unst.Hlea)[3], fixef(cens.unst.Llaf)[3], 
fixef(cens.unst.Lnun)[3], fixef(cens.unst.Lvic)[3], fixef(cens.unst.Meup)[3], 
fixef(cens.unst.Mpho)[3], fixef(cens.unst.Mtyr)[3], fixef(cens.unst.Ound)[3], 
fixef(cens.unst.Oest)[3], fixef(cens.unst.Omel)[3], fixef(cens.unst.Pgign)[3], 
fixef(cens.unst.Pgigs)[3], fixef(cens.unst.Pguy)[3], fixef(cens.unst.Pmal)[3], 
fixef(cens.unst.Pcya)[3], fixef(cens.unst.Tfur)[3]
)) 
cens.unst.trbc
length(cens.unst.trbc)

# Calculate vector of cens (standardized) MCV model estimates: 
cens.unst.mcv <- as.vector(c(
fixef(cens.unst.Amel)[2], fixef(cens.unst.Acas)[2], fixef(cens.unst.Akin)[2], 
fixef(cens.unst.Aama)[2], fixef(cens.unst.Clar)[2], fixef(cens.unst.Coen)[2], 
fixef(cens.unst.Ccoe)[2], fixef(cens.unst.Ciri)[2], fixef(cens.unst.Cvio)[2], 
fixef(cens.unst.Ccor)[2], fixef(cens.unst.Eluc)[2], fixef(cens.unst.Econ)[2], 
fixef(cens.unst.Fmel)[2], fixef(cens.unst.Ghir)[2], fixef(cens.unst.Hame)[2], 
fixef(cens.unst.Hmic)[2], fixef(cens.unst.Hlea)[2], fixef(cens.unst.Llaf)[2], 
fixef(cens.unst.Lnun)[2], fixef(cens.unst.Lvic)[2], fixef(cens.unst.Meup)[2], 
fixef(cens.unst.Mpho)[2], fixef(cens.unst.Mtyr)[2], fixef(cens.unst.Ound)[2], 
fixef(cens.unst.Oest)[2], fixef(cens.unst.Omel)[2], fixef(cens.unst.Pgign)[2], 
fixef(cens.unst.Pgigs)[2], fixef(cens.unst.Pguy)[2], fixef(cens.unst.Pmal)[2], 
fixef(cens.unst.Pcya)[2], fixef(cens.unst.Tfur)[2]
)) 
cens.unst.mcv 
length(cens.unst.mcv)
```




# Make a CeNS Prediction modeling dataset 
```{r}
# Now make a species mean dataset from the cens.ss species-specific subset you used for modeling SS species 
cens.ss.mean <- cens.ss %>% group_by(species) %>% summarise(hb = mean(hb),   
                                                  elev = mean(elev), 
                                                  mass = mean(mass),
                                                  wl = mean(wl),
                                                  mcv = mean(mcv),
                                                  mcv.z = mean(mcv.z),
                                                  trbc = mean(trbc),
                                                  trbc.z = mean(trbc.z),
                                                  mchc = mean(mchc) # need to add mchc.z to cens.ss if you want it
                                                  )
# NEED TO USE CENS.SS for this because it contains all individual data for the pared-down species subset used for species-
# specific CeNS modeling (i.e., cens.sp is a mean dataset but has too many species in it)

# Get genotypes for our CeNS subset 
cens.genotypes <- cens.ss %>% group_by(species, genotype) %>% summarise(count = length(nk)) # Obs/species for ss dataset
cens.genotypes <- cens.genotypes[ , !(colnames(cens.genotypes) %in% c("species"))] # drop species column
# Count is # individuals included per species 

# Add CeNS indices to species-specific mean CeNS data for plotting and later analysis 
cens.ss.mean <- cbind(cens.ss.mean, cens.trbc, cens.mcv, cens.R2, cens.unst.trbc, cens.unst.mcv, cens.genotypes)
cens.ss.mean$mass.log <- log10(cens.ss.mean$mass)

# Cens index: TRBC [3] / MCV [2] + TRBC [3]
# Calculate MCV-oriented CeNS version with: "1-cens.index"
cens.ss.mean$cens.index <- (cens.ss.mean$cens.trbc)/(cens.ss.mean$cens.mcv + cens.ss.mean$cens.trbc)

# write.csv(cens.ss.mean, "cens.ss.mean_ForCeNSmodeling_06-03-21.csv")
```



# CeNS Plots
What does our CeNS index look like in relation to other variables? 
```{r}
# Scatterplot: CeNS index v. elevation  
(p5 <- ggplot(cens.ss.mean, aes(x=elev, y=cens.index)) + # Add shape=Clade here to get shapes to work properly
  geom_point(size=3.4, alpha=1.0) + # cens.ss.mean$mcv/10 = to size by MCV but they don't look super variable
#  geom_text(aes(label=species),hjust=0, vjust=0) + # UNCOMMENT TO ADD SPECIES LABELS TO POINTS
 # scale_colour_viridis(discrete=F) + 
 # scale_color_manual(values = hum_colors) +
 # geom_jitter(width=0.5, height=0.5, alpha=0.8, size=1.1) + # jitter to fill plot space 
   geom_smooth(method = "lm", formula = y ~ x + I(x^2), colour="black", size=1.0) + # quadratic 
  # geom_smooth(method = "lm", size = 1,colour="darkturquoise", size=1.0) + # linear 
  theme_classic() + 
  labs(x="Mean Elevation (m)", y="CeNS Index\n(TRBC/MCV + TRBC)") + # CeNS index = (TRBC/MCV+TRBC)
       # theme(axis.text.x = element_text(hjust = 1)) +
  theme(legend.position = "right") + 
 # ggtitle("A") + # Assign panel number/header; this will be (a) because first in series of 3
  theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
         plot.title = element_text(face="bold")) + # This makes panel header bold 
       # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
  theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left
  theme(axis.text.y=element_text(size=10), axis.text.x=element_text(size=10), axis.title=element_text(size=12))
 )
ggsave(p5, filename="CeNSindex_by_MeanElev_06-03-21.pdf", height=7, width=9, units="in")


# Scatterplot: CeNS index v. wing loading  
(p6 <- ggplot(cens.ss.mean, aes(x=wl, y=cens.index)) + # Add shape=Clade here to get shapes to work properly
  geom_point(size=3.4, alpha=1.0) +
 # geom_text(aes(label=species),hjust=0, vjust=0) + # UNCOMMENT TO ADD SPECIES LABELS TO POINTS
 # scale_colour_viridis(discrete=F) + 
 # scale_color_manual(values = hum_colors) +
 # geom_jitter(width=0.5, height=0.5, alpha=0.8, size=1.1) + # jitter to fill plot space 
 # geom_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1, colour="black", size=1.0) + # quadratic 
  geom_smooth(method = "lm", colour="black", size=1.0) + # linear 
  theme_classic() + 
  labs(x="Wing Loading", y="CeNS Index\n(TRBC/MCV + TRBC)") + # CeNS index = (TRBC/MCV+TRBC)
       # theme(axis.text.x = element_text(hjust = 1)) +
  theme(legend.position = "right") + 
 # ggtitle("A") + # Assign panel number/header; this will be (a) because first in series of 3
  theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
         plot.title = element_text(face="bold")) + # This makes panel header bold 
       # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
  theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left
  theme(axis.text.y=element_text(size=10), axis.text.x=element_text(size=10), axis.title=element_text(size=12))
 )
ggsave(p6, filename="CeNSindex_by_WingLoading_06-03-21.pdf", height=7, width=9, units="in")

# Scatterplot: CeNS index v. Mass  
(p7 <- ggplot(cens.ss.mean, aes(x=mass.log, y=cens.index)) + # Add shape=Clade here to get shapes to work properly
  geom_point(size=3.4, alpha=1.0) +
 # geom_text(aes(label=species),hjust=0, vjust=0) + # UNCOMMENT TO ADD SPECIES LABELS TO POINTS
 # scale_colour_viridis(discrete=F) + 
 # scale_color_manual(values = hum_colors) +
 # geom_jitter(width=0.5, height=0.5, alpha=0.8, size=1.1) + # jitter to fill plot space 
 # geom_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1, colour="black", size=1.0) + # quadratic 
  geom_smooth(method = "lm", colour="black", size=1.0) + # linear 
  theme_classic() + 
  labs(x="Log Mass (g)", y="CeNS Index\n(TRBC/MCV + TRBC)") + # CeNS index = (TRBC/MCV+TRBC)
       # theme(axis.text.x = element_text(hjust = 1)) +
  theme(legend.position = "right") + 
 # ggtitle("A") + # Assign panel number/header; this will be (a) because first in series of 3
  theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
         plot.title = element_text(face="bold")) + # This makes panel header bold 
       # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
  theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left
  theme(axis.text.y=element_text(size=10), axis.text.x=element_text(size=10), axis.title=element_text(size=12))
 )
ggsave(p7, filename="CeNSindex_by_Mass_06-03-21.pdf", height=7, width=9, units="in")

# Since CeNS index suggests that middle elev birds are increasing Blood-O2 carrying capacity through higher TRBC while 
# higher elev species increase blood-O2 carrying capacity through higher MCV, we would expect to see the opposite if 
# the CeNS index was oriented towards MCV; that is, if we plot MCV/MCV+TRBC instead of TRBC/MCV+TRBC
# If plotting cens.index.mcv, we therefore expect a concave shape in our plot; and:
# cens.index and cens.index.mcv values should sum to one

### Plot CeNS index against raw MCV and raw TRBC 

# Scatterplot: CeNS index v. TRBC  
(p <- ggplot(cens.ss.mean, aes(x=trbc, y=cens.index)) + # Had previously colored by MCV
  geom_point(size=3.4, alpha=1.0) +
 # geom_text(aes(label=species),hjust=0, vjust=0) + # UNCOMMENT TO ADD SPECIES LABELS TO POINTS
 scale_colour_viridis(option="rocket", discrete=FALSE, name="MCV (fl)") +  
 # scale_color_manual(values = hum_colors) +
 # geom_jitter(width=0.5, height=0.5, alpha=0.8, size=1.1) + # jitter to fill plot space 
 # geom_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1, colour="black", size=1.0) + # quadratic 
  geom_smooth(method = "lm", colour="black", size=1.0) + # linear 
  theme_classic() + 
  labs(x=expression(TRBC~"("~RBC~x~10^{6}~"/"~mm^{3}~")"), # horrible expression language for getting formatted y axis 
     y="CeNS Index\n(TRBC/MCV + TRBC)") + # Removed x-axis label because we don't want Panel A to have label
 # labs(x="TRBC", y="CeNS Index\n(TRBC/MCV + TRBC)") + # CeNS index = (TRBC/MCV+TRBC)
       # theme(axis.text.x = element_text(hjust = 1)) +
  theme(legend.position = "right") + 
 annotate("text", x=7.1, y=0.70, label = "italic(R) ^ 2 == 0.18", parse = TRUE) + # Add R^2 value from lmer model
 # ggtitle("A") + # Assign panel number/header; this will be (a) because first in series of 3
  theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
         plot.title = element_text(face="bold")) + # This makes panel header bold 
       # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
  theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left
  theme(axis.text.y=element_text(size=10), axis.text.x=element_text(size=10), axis.title=element_text(size=12))
 )
ggsave(p, filename="CeNSindex_by_TRBC.pdf", height=7, width=9, units="in")
# Wtf this is opposite of what I expected - 
# The higher your contribution to using TRBC to increase [Hb], the lower your TRBC value. 

# Correlation matrix 
cor(cens.ss.mean[,c("cens.index", "trbc")]) # -.43

# Quick linear model 
cens.trbc.link.model <- glm(cens.index ~ trbc, data=cens.ss.mean, family=gaussian(), na.action=na.fail)
summary(cens.trbc.link.model)
Anova(cens.trbc.link.model, type=3)
lm_diag_plots(cens.trbc.link.model)
(1 - (cens.trbc.link.model$deviance/cens.trbc.link.model$null.deviance)) # R^2 = 0.18


# Scatterplot: CeNS index v. MCV  
(p <- ggplot(cens.ss.mean, aes(x=mcv, y=cens.index)) + # Add shape=Clade here to get shapes to work properly
  geom_point(size=3.4, alpha=1.0) +
 # geom_text(aes(label=species),hjust=0, vjust=0) + # UNCOMMENT TO ADD SPECIES LABELS TO POINTS
  scale_colour_viridis(option="rocket", discrete=FALSE, name="TRBC") + 
 # scale_color_manual(values = hum_colors) +
 # geom_jitter(width=0.5, height=0.5, alpha=0.8, size=1.1) + # jitter to fill plot space 
 # geom_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1, colour="black", size=1.0) + # quadratic 
  geom_smooth(method = "lm", colour="black", size=1.0) + # linear 
  theme_classic() + 
  labs(x="MCV (fl)", y="CeNS Index\n(TRBC/MCV + TRBC)") + # CeNS index = (TRBC/MCV+TRBC)
       # theme(axis.text.x = element_text(hjust = 1)) +
  theme(legend.position = "right") + 
  annotate("text", x=105, y=0.70, label = "italic(R) ^ 2 == 0.25", parse = TRUE) + # Add R^2 value from lmer model
 # ggtitle("A") + # Assign panel number/header; this will be (a) because first in series of 3
  theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
         plot.title = element_text(face="bold")) + # This makes panel header bold 
       # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
  theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left
  theme(axis.text.y=element_text(size=10), axis.text.x=element_text(size=10), axis.title=element_text(size=12))
 )
ggsave(p, filename="CeNSindex_by_MCV.pdf", height=7, width=9, units="in")

# Correlation matrix 
cor(cens.ss.mean[,c("cens.index", "mcv")]) # 0.50

# Quick linear model 
cens.mcv.link.model <- glm(cens.index ~ mcv, data=cens.ss.mean, family=gaussian(), na.action=na.fail)
summary(cens.mcv.link.model) # As MCV increases, ceNS index increases 
Anova(cens.mcv.link.model, type=3) # significant; p = 0.003
lm_diag_plots(cens.mcv.link.model)
(1 - (cens.mcv.link.model$deviance/cens.mcv.link.model$null.deviance)) # R^2 = 0.25

# Scatterplot: TRBC v. MCV colored by Cens.index 
(p <- ggplot(cens.ss.mean, aes(x=mcv, y=trbc, colour=cens.index)) + # Add shape=Clade here to get shapes to work properly
  geom_point(size=5.4, alpha=1.0) +
 # geom_text(aes(label=species),hjust=0, vjust=0) + # UNCOMMENT TO ADD SPECIES LABELS TO POINTS
 scale_colour_viridis(option="viridis", discrete=FALSE, name="CeNS\nIndex") +  
 # scale_color_manual(values = hum_colors) +
 # geom_jitter(width=0.5, height=0.5, alpha=0.8, size=1.1) + # jitter to fill plot space 
 # geom_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1, colour="black", size=1.0) + # quadratic 
 # geom_smooth(method = "lm", colour="black", size=1.0) + # linear 
  theme_classic() + 
  labs(x="Mean MCV (fl)", y="Mean TRBC") + # CeNS index = (TRBC/MCV+TRBC)
       # theme(axis.text.x = element_text(hjust = 1)) +
  theme(legend.position = "right") + 
 # ggtitle("A") + # Assign panel number/header; this will be (a) because first in series of 3
  theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
         plot.title = element_text(face="bold")) + # This makes panel header bold 
       # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
  theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left
  theme(axis.text.y=element_text(size=10), axis.text.x=element_text(size=10), axis.title=element_text(size=12))
 )
ggsave(p, filename="TRBC_versus_MCV_ColoredByCensIndex.pdf", height=7, width=9, units="in")
# This is TOTALLY confusing to me 


# Are heavier birds more sensitive to shifts in cell number? 
# Scatterplot: TRBC v. MCV colored by Cens.index 
(p <- ggplot(cens.ss.mean, aes(y=trbc, x=mass.log)) + # Had previously colored by MCV
  geom_point(size=3.4, alpha=1.0) +
 # geom_text(aes(label=species),hjust=0, vjust=0) + # UNCOMMENT TO ADD SPECIES LABELS TO POINTS
 #scale_colour_viridis(option="rocket", discrete=FALSE, name="MCV (fl)") +  
 # scale_color_manual(values = hum_colors) +
 # geom_jitter(width=0.5, height=0.5, alpha=0.8, size=1.1) + # jitter to fill plot space 
 # geom_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1, colour="black", size=1.0) + # quadratic 
#  geom_smooth(method = "lm", colour="black", size=1.0) + # linear 
  theme_classic() + 
  labs(y=expression(TRBC~"("~RBC~x~10^{6}~"/"~mm^{3}~")"), # horrible expression language for getting formatted y axis 
     x="Mass (log-transformed)") + # Removed x-axis label because we don't want Panel A to have label
 # labs(x="TRBC", y="CeNS Index\n(TRBC/MCV + TRBC)") + # CeNS index = (TRBC/MCV+TRBC)
       # theme(axis.text.x = element_text(hjust = 1)) +
  theme(legend.position = "right") + 
# annotate("text", x=7.1, y=0.70, label = "italic(R) ^ 2 == 0.18", parse = TRUE) + # Add R^2 value from lmer model
 # ggtitle("A") + # Assign panel number/header; this will be (a) because first in series of 3
  theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
         plot.title = element_text(face="bold")) + # This makes panel header bold 
       # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
  theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left
  theme(axis.text.y=element_text(size=10), axis.text.x=element_text(size=10), axis.title=element_text(size=12))
 )
ggsave(p, filename="TRBC_versus_Mass.pdf", height=7, width=9, units="in")

# Correlation matrix 
cor(cens.ss.mean[,c("trbc", "mass.log")]) # -0.14


# Are larger birds more sensitive to shifts in cell size? 
# MCV v. mass 
(p <- ggplot(cens.ss.mean, aes(x=mass.log, y=mcv)) + # Add shape=Clade here to get shapes to work properly
  geom_point(size=3.4, alpha=1.0) +
 # geom_text(aes(label=species),hjust=0, vjust=0) + # UNCOMMENT TO ADD SPECIES LABELS TO POINTS
 #scale_colour_viridis(option="viridis", discrete=FALSE, name="CeNS\nIndex") +  
 # scale_color_manual(values = hum_colors) +
 # geom_jitter(width=0.5, height=0.5, alpha=0.8, size=1.1) + # jitter to fill plot space 
 # geom_smooth(method = "lm", formula = y ~ x + I(x^2), size = 1, colour="black", size=1.0) + # quadratic 
 # geom_smooth(method = "lm", colour="black", size=1.0) + # linear 
  theme_classic() + 
  labs(y="Mean MCV (fl)", x="Mass (log-transformed") + # CeNS index = (TRBC/MCV+TRBC)
       # theme(axis.text.x = element_text(hjust = 1)) +
  theme(legend.position = "right") + 
 # ggtitle("A") + # Assign panel number/header; this will be (a) because first in series of 3
  theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
         plot.title = element_text(face="bold")) + # This makes panel header bold 
       # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
  theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left
  theme(axis.text.y=element_text(size=10), axis.text.x=element_text(size=10), axis.title=element_text(size=12))
 )
ggsave(p, filename="MCV_versus_Mass.pdf", height=7, width=9, units="in")

# Correlation matrix 
cor(cens.ss.mean[,c("mcv", "mass.log")]) # 0.17


# Hemoglobin genotype and CeNS Index
(p22 <- ggplot(cens.ss.mean, aes(x=genotype, y=cens.index)) +
       # facet_wrap(~sex, nrow=2) + 
        geom_boxplot(aes(fill = factor(genotype)), outlier.size=2.0, alpha=0.7) +
        geom_jitter(position = position_jitter(width = 0.01), alpha = 0.5, size = 2.0) +
        stat_summary(fun=mean, colour="firebrick1", geom="point", shape=18, size=6) + # Red diamonds at mean 
        theme_classic() +   # theme_classic() removes all gridlines; theme_bw() retains subtle nice gridlines           
        theme(panel.grid.minor = element_blank()) +
        labs(y="CeNS Index", # Hella confusing formatting for x and y axis labels 
             x="Clade") +
        theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
        theme(legend.position = "none") +
        theme(axis.text.y=element_text(size=10), axis.text.x=element_text(size=12), axis.title=element_text(size=14))
)


# Scatterplot: CeNS Index v. unstandardized cens MCV estimate   
(p <- ggplot(cens.ss.mean, aes(x=mchc, y=cens.index)) + # Add shape=Clade here to get shapes to work properly
  geom_point(size=2.4, alpha=1.0) +
 # geom_text(aes(label=species),hjust=0, vjust=0) + # UNCOMMENT TO ADD SPECIES LABELS TO POINTS
  #geom_smooth(method = "lm", colour="black", size=1.0) + # linear 
  theme_classic() + 
  labs(x="MCHC", y="CeNS Index") + # Remove CeNS index y-axis label for shared plot
       # theme(axis.text.x = element_text(hjust = 1)) +
  theme(legend.position = "right") + 
  annotate("text", x=34.2, y=0.70, label = "italic(R) ^ 2 == 0.004", parse = TRUE) + # Add R^2 value from lmer model
  annotate("text", x=34.2, y=0.66, label = "italic(r) == -0.06", parse = TRUE) + # Add r correlation coefficient
  # ggtitle("E") + # Assign panel number/header; this will be (a) because first in series of 3
  theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
         plot.title = element_text(face="bold")) + # This makes panel header bold 
       # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
  theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left
  theme(axis.text.y=element_text(size=10), axis.text.x=element_text(size=10), axis.title=element_text(size=12))
 )
ggsave(p, filename="CeNSIndex_Versus_MCHC.pdf", height=7, width=9, units="in")

# Correlation matrix 
cor(cens.ss.mean[,c("cens.index", "mchc")])
# Fairly strong negative correlation between CeNS index and unstandardized MCV values: value = -0.06

# Quick linear model 
cens.index.mchc.model <- glm(cens.index ~ mchc, data=cens.ss.mean, family=gaussian(), na.action=na.fail)
summary(cens.index.mchc.model)
Anova(cens.index.mchc.model, type=3) # No, MCHC not predictor of CENS
lm_diag_plots(cens.index.mchc.model)
(1 - (cens.index.mchc.model$deviance/cens.index.mchc.model$null.deviance)) # R^2 = 0.004

# Answer: Yes, cens.index is strongly negatively correlated with unstandardized MCV estimates 
# The higher the unstandardized MCV coefficient, the lower the CeNS index (aka, greater contribution of)
```



# FIGURE S4: CENS DIAGNOSTIC PLOT - correlations between R^2, TRBC estimates, and MCV estimates
```{r}
# Firstly, Let's assess possible correlation between the CeNS index and better fitting models - do better or worse fitting # models consistently have certain CeNS values? 

# Scatterplot: CeNS Index v. R^2 
(s4.1 <- ggplot(cens.ss.mean, aes(x=cens.R2, y=cens.index)) + # Add shape=Clade here to get shapes to work properly
  geom_point(size=2.4, alpha=1.0) +
 # geom_text(aes(label=species),hjust=0, vjust=0) + # UNCOMMENT TO ADD SPECIES LABELS TO POINTS
 # geom_smooth(method = "lm", colour="black", size=1.0) + # linear 
  theme_classic() + 
  labs(x=expression(CeNS~Model~italic(R)^{2}), y="CeNS Index (0-1)") + # CeNS index = (TRBC/MCV+TRBC)
       # theme(axis.text.x = element_text(hjust = 1)) +
  theme(legend.position = "right") + 
  annotate("text", x=0.8, y=0.70, label = "italic(R) ^ 2 == 0.06", parse = TRUE) + # Add R^2 value from lmer model
  annotate("text", x=0.8, y=0.68, label = "italic(r) == -0.23", parse = TRUE) + # Add r correlation coefficient
  ggtitle("A") + # Assign panel number/header; this will be (a) because first in series of 3
  theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
         plot.title = element_text(face="bold")) + # This makes panel header bold 
       # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
  theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left
  theme(axis.text.y=element_text(size=10), axis.text.x=element_text(size=10), axis.title=element_text(size=12))
 )
ggsave(s4.1, filename="CensIndex_Versus_R^2.pdf", height=7, width=9, units="in")

# Correlation matrix 
cor(cens.ss.mean[,c("cens.index", "cens.R2")])
# No correlation between R^2 values and the CeNS index: value = -0.23

# Quick linear model 
cens.R2.index.model <- glm(cens.index ~ cens.R2, data=cens.ss.mean, family=gaussian(), na.action=na.fail)
summary(cens.R2.index.model)
Anova(cens.R2.index.model, type=3)
lm_diag_plots(cens.R2.index.model)
(1 - (cens.R2.index.model$deviance/cens.R2.index.model$null.deviance)) # R^2 = 0.06

# Answer: No! Cens index is *not* correlated with R^2 values from models. This is good, suggests there isn't an 
# artifactual pattern of better or worse fitting models producing similar CeNS values. 


####

# Is cens.index correlated with STANDARDIZED TRBC estimates? 

# Scatterplot: CeNS Index v. unstandardized cens trbc estimate   
(s4.2 <- ggplot(cens.ss.mean, aes(x=cens.trbc, y=cens.index)) + # Add shape=Clade here to get shapes to work properly
  geom_point(size=2.4, alpha=1.0) +
 # geom_text(aes(label=species),hjust=0, vjust=0) + # UNCOMMENT TO ADD SPECIES LABELS TO POINTS
 # geom_smooth(method = "lm", colour="black", size=1.0) + # linear 
  theme_classic() + 
  labs(x="CeNS TRBC Estimate\n(Standardized)", y="") + # Remove CeNS index y-axis label for shared plot
       # theme(axis.text.x = element_text(hjust = 1)) +
  theme(legend.position = "right") + 
  annotate("text", x=3.2, y=0.70, label = "italic(R) ^ 2 == 0.07", parse = TRUE) + # Add R^2 value from lmer model
  annotate("text", x=3.2, y=0.66, label = "italic(r) == -0.27", parse = TRUE) + # Add r correlation coefficient
  ggtitle("B") + # Assign panel number/header; this will be (a) because first in series of 3
  theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
         plot.title = element_text(face="bold")) + # This makes panel header bold 
       # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
  theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left
  theme(axis.text.y=element_text(size=10), axis.text.x=element_text(size=10), axis.title=element_text(size=12))
 )
ggsave(s4.2, filename="CeNSIndex_Versus_StandardizedTRBCEstimate.pdf", height=7, width=9, units="in")
# Coeligena coeligena is the super weird outlier point 

# Correlation matrix 
cor(cens.ss.mean[,c("cens.index", "cens.trbc")])
# No correlation between R^2 values and the CeNS index: value = -0.27

# Quick linear model 
cens.index.sttrbc.model <- glm(cens.index ~ cens.trbc, data=cens.ss.mean, family=gaussian(), na.action=na.fail)
summary(cens.index.sttrbc.model)
Anova(cens.index.sttrbc.model, type=3)
lm_diag_plots(cens.index.sttrbc.model)
(1 - (cens.index.sttrbc.model$deviance/cens.index.sttrbc.model$null.deviance)) # R^2 = 0.07


# Is cens.index correlated with UNSTNDARDIZED TRBC estimates? 

# Scatterplot: CeNS Index v. unstandardized cens trbc estimate   
(s4.3 <- ggplot(cens.ss.mean, aes(x=cens.unst.trbc, y=cens.index)) + # Add shape=Clade here to get shapes to work properly
  geom_point(size=2.4, alpha=1.0) +
 # geom_text(aes(label=species),hjust=0, vjust=0) + # UNCOMMENT TO ADD SPECIES LABELS TO POINTS
 # geom_smooth(method = "lm", colour="black", size=1.0) + # linear 
  theme_classic() + 
  labs(x="CeNS TRBC Estimate\n(Unstandardized)", y="") + # Remove CeNS index y-axis label for shared plot
       # theme(axis.text.x = element_text(hjust = 1)) +
  theme(legend.position = "right") + 
  annotate("text", x=3.2, y=0.70, label = "italic(R) ^ 2 == 0.07", parse = TRUE) + # Add R^2 value from lmer model
  annotate("text", x=3.2, y=0.66, label = "italic(r) == -0.26", parse = TRUE) + # Add r correlation coefficient
  ggtitle("C") + # Assign panel number/header; this will be (a) because first in series of 3
  theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
         plot.title = element_text(face="bold")) + # This makes panel header bold 
       # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
  theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left
  theme(axis.text.y=element_text(size=10), axis.text.x=element_text(size=10), axis.title=element_text(size=12))
 )
ggsave(s4.3, filename="CeNSIndex_Versus_UnstandardizedTRBCEstimate.pdf", height=7, width=9, units="in")
# Coeligena coeligena is the super weird outlier point 

# Correlation matrix 
cor(cens.ss.mean[,c("cens.index", "cens.unst.trbc")])
# No correlation between R^2 values and the CeNS index: value = -0.26

# Quick linear model 
cens.index.unsttrbc.model <- glm(cens.index ~ cens.unst.trbc, data=cens.ss.mean, family=gaussian(), na.action=na.fail)
summary(cens.index.unsttrbc.model)
Anova(cens.index.unsttrbc.model, type=3)
lm_diag_plots(cens.index.unsttrbc.model)
(1 - (cens.index.unsttrbc.model$deviance/cens.index.unsttrbc.model$null.deviance)) # R^2 = 0.07

# Answer: No! Cens index is *not* correlated with unstandardized TRBC values from models. 


##### 

# Is cens.index correlated with STANDARDIZED MCV estimates? 

# Scatterplot: CeNS Index v. unstandardized cens MCV estimate   
(s4.4 <- ggplot(cens.ss.mean, aes(x=cens.mcv, y=cens.index)) + # Add shape=Clade here to get shapes to work properly
  geom_point(size=2.4, alpha=1.0) +
 # geom_text(aes(label=species),hjust=0, vjust=0) + # UNCOMMENT TO ADD SPECIES LABELS TO POINTS
  geom_smooth(method = "lm", colour="black", size=1.0) + # linear 
  theme_classic() + 
  labs(x="CeNS MCV Model Estimate\n(Standardized)", y="") + # Remove CeNS index y-axis label for shared plot
       # theme(axis.text.x = element_text(hjust = 1)) +
  theme(legend.position = "right") + 
  annotate("text", x=3.2, y=0.70, label = "italic(R) ^ 2 == 0.51", parse = TRUE) + # Add R^2 value from lmer model
  annotate("text", x=3.2, y=0.66, label = "italic(r) == -0.71", parse = TRUE) + # Add r correlation coefficient
  ggtitle("D") + # Assign panel number/header; this will be (a) because first in series of 3
  theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
         plot.title = element_text(face="bold")) + # This makes panel header bold 
       # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
  theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left
  theme(axis.text.y=element_text(size=10), axis.text.x=element_text(size=10), axis.title=element_text(size=12))
 )
ggsave(s4.4, filename="CeNSIndex_Versus_MCVEstimateStandardized.pdf", height=7, width=9, units="in")


# Correlation matrix 
cor(cens.ss.mean[,c("cens.index", "cens.mcv")])
# Fairly strong negative correlation between CeNS index and unstandardized MCV values: value = -0.7

# Quick linear model 
cens.index.stmcv.model <- glm(cens.index ~ cens.mcv, data=cens.ss.mean, family=gaussian(), na.action=na.fail)
summary(cens.index.stmcv.model)
Anova(cens.index.stmcv.model, type=3) # yes, unstandardized MCV is a significant predictor of CeNS index
lm_diag_plots(cens.index.stmcv.model)
(1 - (cens.index.stmcv.model$deviance/cens.index.stmcv.model$null.deviance)) # R^2 = 0.51


# Is cens.index correlated with UNSTANDARDIZED MCV estimates? 

# Scatterplot: CeNS Index v. unstandardized cens MCV estimate   
(s4.5 <- ggplot(cens.ss.mean, aes(x=cens.unst.mcv, y=cens.index)) + # Add shape=Clade here to get shapes to work properly
  geom_point(size=2.4, alpha=1.0) +
 # geom_text(aes(label=species),hjust=0, vjust=0) + # UNCOMMENT TO ADD SPECIES LABELS TO POINTS
  geom_smooth(method = "lm", colour="black", size=1.0) + # linear 
  theme_classic() + 
  labs(x="CeNS MCV Model Estimate\n(Unstandardized)", y="") + # Remove CeNS index y-axis label for shared plot
       # theme(axis.text.x = element_text(hjust = 1)) +
  theme(legend.position = "right") + 
  annotate("text", x=0.25, y=0.70, label = "italic(R) ^ 2 == 0.45", parse = TRUE) + # Add R^2 value from lmer model
    annotate("text", x=0.25, y=0.66, label = "italic(r) == -0.67", parse = TRUE) + # Add r correlation coefficient
  ggtitle("E") + # Assign panel number/header; this will be (a) because first in series of 3
  theme(plot.title.position = "plot", # parameter "plot" specifies that you want "title" flush with y-axis
         plot.title = element_text(face="bold")) + # This makes panel header bold 
       # This is good for labeling figure panels! Avoids having to manually toy w/ hjust and vjust
  theme(plot.margin = unit(c(0.2,0.1,0.0,0.2), "cm")) +  # top, right, bottom, left
  theme(axis.text.y=element_text(size=10), axis.text.x=element_text(size=10), axis.title=element_text(size=12))
 )
ggsave(s4.5, filename="CeNSIndex_Versus_MCVEstimateUnstandardized.pdf", height=7, width=9, units="in")


# Correlation matrix 
cor(cens.ss.mean[,c("cens.index", "cens.unst.mcv")])
# Fairly strong negative correlation between CeNS index and unstandardized MCV values: value = -0.67

# Quick linear model 
cens.index.unstmcv.model <- glm(cens.index ~ cens.unst.mcv, data=cens.ss.mean, family=gaussian(), na.action=na.fail)
summary(cens.index.unstmcv.model)
Anova(cens.index.unstmcv.model, type=3) # yes, unstandardized MCV is a significant predictor of CeNS index
lm_diag_plots(cens.index.unstmcv.model)
(1 - (cens.index.unstmcv.model$deviance/cens.index.unstmcv.model$null.deviance)) # R^2 = 0.45

# Answer: Yes, cens.index is strongly negatively correlated with unstandardized MCV estimates 
# The higher the unstandardized MCV coefficient, the lower the CeNS index (aka, greater contribution of)


#### FINAL PLOT #####

library(patchwork)
# Alternative layout option = BETTER, USE THIS ONE:
FigureS4_5panel_CeNSDiagnostics <- (s4.1 | s4.2 + s4.3 + s4.4 + s4.5 +
                                    plot_layout(guides = "collect"))
plot(FigureS4_5panel_CeNSDiagnostics)
ggsave(FigureS4_5panel_CeNSDiagnostics, filename = "FigureS4_5panel_CeNSDiagnostics_06-03_21.pdf", bg="transparent", height=6.8, width=12, units="in")
```

Some thoughts: Why did we choose to calculate cens index with estimates from models versus from raw data? Because we want each parameter's relative contribution to driving hemoglobin concentration, which we can't get without model estimates; pulling betas from models gives us the link to Hb. And perhaps what's interesting here is that after modeling this link, we actually find the opposite of what we do by analyzing the raw data: We do *not* see the concave/flipped parabola shape, which suggests that middle-elev species are increasing blood-O2 carrying capacity through higher MCV; instead what we find is that middle elev species are primarily increasing blood-O2 carrying capacity through increases in TRBC. This differs from the process of human acclimatization to altitude. Low and high elevation species both increase blood-o2 carrying capacity through increases through having bigger cells and fewer of them (higher MCV), but this effect is much stronger in high elevation hummingbird species, which have larger cells. 


######

#### CENS PREDICTION MODELING

# What predicts CeNS index? 
```{r}
# READ IN CENS TREE
# I took tree.final file and pruned to the subset of species in the CeNS species-specific model set 
# Phylogeny pruned from McGuire and adjusted (see script HumBlood_Phylogeny.Rmd)
tree.cens <- read.tree("HumBlood_CeNS_Modeling_Tree_FINAL.tre") # a list 
tree.cens$tip.label # Check 32 tips

# Are the phylogeny tip labels in the data and vice-versa?
tree.cens$tip.label %in% cens.ss.mean$species # yes
sum(tree.cens$tip.label %in% cens.ss.mean$species) # sum = 32
summary(tree.cens$tip.label %in% cens.ss.mean$species) # yes 

# Standardize model inputs: 
cens.ss.mean$elev.z <- standardize(cens.ss.mean$elev)
cens.ss.mean$mass.z <- standardize(cens.ss.mean$mass.log) # standardized mean mass (log-transformed)
cens.ss.mean$wl.z <- standardize(cens.ss.mean$wl)
```


# Check distributions and correlations
```{r}
# Take a look at distribution of data 
p <- ggpairs(subset(cens.ss.mean, select = c(cens.index, elev.z, mass.z, wl.z, genotype))); p

# Correlation matrix 
cor(cens.ss.mean[,c("elev.z","mass.z", "wl.z", "cens.index")])
# Wing loading correlated with elev
```


# CeNS Phylogenetic Signal and Contmaps 
```{r}
# CONTMAPS 

# NOTE: See Lisa's tutorial on this, called amphibian_PhyloMethods_Mar2020.R" - more helpful than Phytools tutorials! 
# IMPORTANT: don't forget to attach species names to the trait! 
# AND, don't do this with rownames(), which changes data format. Do this as Lisa has done w/ 'names()'. 
# You want the format to read 'Named num'; class = numeric; type = double 

cens.contmap <- cens.ss.mean %>% group_by(species) %>% summarise(cens.index = mean(cens.index))  
just.cens <- cens.contmap$cens.index
names(just.cens) <- cens.contmap$species 
class(just.cens); typeof(just.cens) #; View(just.hct)

# Make contmap object
cens.cont.tree <- contMap(tree.cens, just.cens, plot=TRUE, outline=FALSE) 

# Plot map and save to pdf w/ proper aesthetics 
pdf(file="CeNS.index.contmap.pdf", width=6, height=6) # Write plot to pdf 
#hct.cont.tree$cols[1:n] <- viridis(n) # Manually set color scale to viridis 
plot.contMap(cens.cont.tree, just.cens, res=200, fsize=0.4, lwd=2, leg.txt="CeNS Index", outline=FALSE) # Manually plot using phytools
dev.off()


# PHYLO SIGNAL 
# Compute two metrics of phylogenetic signal: Blomberg's K and Pagel's lamda 
# Pagel's lambda: 0 = no phylo singal in the trait and 1 = phylo signal in the trait
# Blomberg's K: computed w/ p-val by comparing real data to null distribution obtained by random permuations. 
    # Values of K range from 0 to inf; K=1 = Brownian motion evol; k>1 = spp more similar than expected under random drift; 
    # k<1 = spp less similar than expected under random drift. The larger the K, the stronger the phylo signal. 
    # Generally, only K-values with significant p-vals indicate phylo signal

# x must be a vector of a continuously distributed trait; use 'just.cens' vector of mean values created for contmaps 
# w/ phylosig(), default is method="K" and nsim=1000

set.seed(5555)

# Compute Blomberg's K
phylosig(tree=tree.cens, x=just.cens, method="K", test=TRUE) # K=0.44, p=0.241

# Compute Pagel's lambda using maximum likelihood
phylosig(tree=tree.cens, x=just.cens, method="lambda", test=TRUE) # lambda=<0, p=1

# --> NO PHYLO SIGNAL IN OUR CENS DATA!
```



# CENS PREDICTION MODELS 
In addition to the above contmaps and tests of phylo signal, I ran a first pass at models w/ phylogeny incorporated. Buerkner's hypothesis test supported lack of phylo signal, and only ~4% of the variance was explained by phylogeny. Since this is a poor predictor, remove this from our model plan. 
```{r}
# cens.index is alarmingly normally distributed, so start with gaussian 

# Remember to use 'cens.ss.mean' because the 'cens.mod' dataframe has no Patagona_gigas_S! (Was for phylo modeling only)

job::job({ # Send to a job to free up console
set.seed(12456)
  
# MODEL 1: NULL MODEL (INTERCEPT ONLY) 
cens.m1 <- brm(
  formula = bf(cens.index ~ 1),
  data = cens.ss.mean,
  family = gaussian(),
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, #Nora had 10,000; default is iter/2; shouldn't ever be larger than iter
  iter = 20000, # nora had 20000
  control = list(adapt_delta = 0.99, max_treedepth = 15),
  sample_prior = TRUE # save priors 
)
save(cens.m1, file="cens.m1_CeNS_Intercept-Only.RData") # save model
# load("hb.m1_CeNS_Intercept-Only.Rdata") 

# MODEL 2: FULL MODEL, NO QUADRATIC
cens.m2 <- brm(
  formula = bf(cens.index ~ 1 + elev.z + mass.z + wl.z),
  data = cens.ss.mean,
  family = gaussian(), 
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, 
  iter = 20000, 
  control = list(adapt_delta = 0.99, max_treedepth = 15),
  sample_prior = TRUE # save priors 
)
save(cens.m2, file="cens.m2_CeNS_FullModel_PredictorsWithoutQuadratic.RData") # save model
# load("cens.m2_CeNS_FullModel_PredictorsWithoutQuadratic.RData") # If loading from pre-saved file and not re-running

# MODEL 3: FULL MODEL WITH QUADRATIC
cens.m3 <- brm(
  formula = bf(cens.index ~ 1 + elev.z + I(elev.z^2) + mass.z + wl.z),
  data = cens.ss.mean,
  family = gaussian(), 
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, 
  iter = 20000, 
  control = list(adapt_delta = 0.99, max_treedepth = 15),
  sample_prior = TRUE # save priors 
)
save(cens.m3, file="cens.m3_CeNS_FullModel_PredictorsWithQuadratic.RData") # save model
# load("cens.m3_CeNS_FullModel_PredictorsWithQuadratic.RData") # If loading from pre-saved file and not re-running

# MODEL 4: FULL MODEL WITH QUADRATIC
cens.m4 <- brm(
  formula = bf(cens.index ~ 1 + elev.z + I(elev.z^2) + mass.z + wl.z + genotype),
  data = cens.ss.mean,
  family = gaussian(), 
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, 
  iter = 20000, 
  control = list(adapt_delta = 0.99, max_treedepth = 15),
  sample_prior = TRUE # save priors 
)
save(cens.m4, file="cens.m4_CeNS_FullModel_PredictorsWithQuadratic&Genotype.RData") # save model
# load("cens.m4_CeNS_FullModel_PredictorsWithQuadratic&Genotype.RData") # If loading from pre-saved file and not re-running
})
```


# Cens: Summarize and check fit for full models 
Explanation of what mcmc_plot output below means: https://cran.r-project.org/web/packages/bayesplot/vignettes/plotting-mcmc-draws.html
```{r}
# FIT AND CONVERGENCE 
mcmc_plot(cens.m3, type = "trace") 
plot(cens.m3, N = 2, ask = FALSE)
mcmc_plot(cens.m3, type = "acf_bar")

bayesplot::pp_check(cens.m3, resp = "cens.index", nsamples = 200) 
bayesplot::pp_check(cens.m3, type = "stat_2d", nsamples = 100)

# conditional effects
plot(conditional_effects(cens.m2), points = TRUE) 

# Quick plot of estimates and 95% CIs (default is 95% CI:
mcmc_plot(cens.m2)  # adjust prob to get 95% CI

# Residual plots 
# typical residual plot but w/ addition of uncertainty associated w/ each residual given by generating draws from the dist 
# associated with each residual
cens.ss.mean %>%
  add_residual_draws(cens.m2) %>%
  ggplot(aes(x = .row, y = .residual)) +
  stat_pointinterval()

# qqPlots
cens.ss.mean %>%
  add_predicted_draws(cens.m2) %>%
  summarise(
    p_residual = mean(.prediction < cens.index), # probability residual; Bayesian predictive p-value 
    z_residual = qnorm(p_residual) # quantile residuals 
  ) %>%
  ggplot(aes(sample = z_residual)) +
  geom_qq() +
  geom_abline()
# If predicted distribution is uniform, probabilities should be well calibrated
```



# Cens: Plot outputs of posterior mean estimates and 95% credible intervals (full models, m1-m6)
```{r}
# Plot: Posterior mean estimates and 95% credible intervals for predictors.
# Plot these nicely and without intercepts, which throws off scale: 
# This is a graphical way to look at model fit as opposed to just dumping out model output
# Circle = point estimate (model summary, print(hb.m6))
# Thin bars = default 90% CI; adjust prob_outer=0.95 to get 95% CI 
# Thick bars = default 50% CI; adjust prob=0.50 to get anything else 
# x-axis should be scale based on value of estimates coming out of the model 

# Model 2 
#pairs(hb.m3)
color_scheme_set("viridisD") # nice default
cens.m2.p1 <- mcmc_plot(cens.m2, pars=c("b_elev.z", "b_mass.z","b_wl.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on CeNS Index", title = "cens.m2") + 
scale_y_discrete(labels=c("Elevation","Mass", "Wing Loading"))  
cens.m2.p1
ggsave(cens.m2.p1, filename = "cens.m2.p1_CensIndex_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")
summary(cens.m2)
# Predictors that don't overlap zero: None

# Model 3 
cens.m3.p1 <- mcmc_plot(cens.m3, pars=c("b_elev.z", "b_Ielev.zE2","b_mass.z","b_wl.z"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on CeNS Index", title = "cens.m3") + 
scale_y_discrete(labels=c("Elevation", "Elevation^2","Mass", "Wing Loading"))  
cens.m3.p1
ggsave(cens.m3.p1, filename = "cens.m3.p1_CensIndex_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")
summary(cens.m3)
# Predictors that don't overlap zero: elev, elev quadratic, mass

# Model 4 
cens.m4.p1 <- mcmc_plot(cens.m4, pars=c("b_elev.z", "b_Ielev.zE2","b_mass.z","b_wl.z","b_genotypeGlyMSer", "b_genotypeSerMSer"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on CeNS Index", title = "cens.m4") + 
scale_y_discrete(labels=c("Elevation", "Elevation^2","Mass", "Wing Loading", "Genotype (Gly-Ser)", "Genotype (Ser-Ser)"))
cens.m4.p1
ggsave(cens.m4.p1, filename = "cens.m4.p1_CensIndex_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")
summary(cens.m4)
# Predictors that don't overlap zero: elev, elev quadratic

# Summary of reduced models: 
# m5 (reduced m3) will be: elev.z + I(elev.z^2) + mass.z
# m6 (reduced m4) will be: elev.z + I(elev.z^2)
```


# Hb: Collate model summaries and WAIC scores for full models (m1-m6)
```{r}
# Print model summaries 
sink("hb_brms_model_summaries.txt",append = TRUE)
summary(cens.m1, waic=TRUE)
summary(cens.m2, waic=TRUE)
summary(cens.m3, waic=TRUE)
summary(cens.m4, waic=TRUE)
sink()
# print(cens.test, prob=0.95) # change CI cut-off by adjusting prob; remember Bayesian default may not be 95%

# Get model WAIC scores  
cens.m1.waic <- waic(cens.m1)
cens.m2.waic <- waic(cens.m2)
cens.m3.waic <- waic(cens.m3)
cens.m4.waic <- waic(cens.m4)
cens.waics <- cbind(cens.m1.waic, cens.m2.waic, cens.m3.waic, cens.m4.waic); cens.waics
write.csv(cens.waics, "cens_brms_models_waics.csv") # totally unintelligible cumbersome doc w/ all pointwise comparisons 
```


# cens: RUN REDUCED MODELS (m5-m6)
```{r}
# MODEL 5: REDUCED MODEL WITH NO RANDOM EFFECTS (JUST PREDICTORS)
cens.m5 <- brm(
  formula = bf(cens.index ~ 1 + elev.z + I(elev.z^2) + mass.z),
  data = cens.ss.mean,
  family = gaussian(), # estimates of  mean and sd in t dist are robust to outliers relative to normal dist
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000,
  control = list(adapt_delta = 0.99, max_treedepth = 15),
  sample_prior = TRUE # save priors
)
save(cens.m5, file="cens.m5_CeNS_ReducedModel_PredictorsOnly.RData") # save model
#load("cens.m5_CeNS_ReducedModel_PredictorsOnly.RData") # If loading from pre-saved file and not re-running

# MODEL 6: REDUCED MODEL 
cens.m6 <- brm(
  formula = bf(cens.index ~ 1 + elev.z + I(elev.z^2)),
  data = cens.ss.mean,
  family = gaussian(), # estimates of  mean and sd in t dist are robust to outliers relative to normal dist
  cores = 4,
  chains = 4,
  thin = 10,
  warmup = 10000, # default is iter/2; shouldn't ever be larger than iter
  iter = 20000, 
  control = list(adapt_delta = 0.99, max_treedepth = 15),
  sample_prior = TRUE # save priors 
)
save(cens.m6, file="cens.m6_CeNS_ReducedModel.RData") # save model
# load("cens.m6_CeNS_ReducedModel.RData") 
```


# cens: Plot outputs of posterior mean estimates and 95% credible intervals (full models, m1-m6)
```{r}
# Plot: Posterior mean estimates and 95% credible intervals for predictors.
# Plot these nicely and without intercepts, which throws off scale: 
# This is a graphical way to look at model fit as opposed to just dumping out model output
# Circle = point estimate (model summary, print(cens.m6))
# Thin bars = default 90% CI; adjust prob_outer=0.95 to get 95% CI 
# Thick bars = default 50% CI; adjust prob=0.50 to get anything else 
# x-axis should be scale based on value of estimates coming out of the model 

# # Model 5 
color_scheme_set("viridisD") # nice default
cens.m5.p1 <- mcmc_plot(cens.m5, pars=c("b_elev.z", "b_Ielev.zE2", "b_mass.z"),
                                    prob_outer=0.95, # 95% outer CI
                                    prob=0.50, # 50% inner CI
                                    point_est="mean") + # mean point est; default is median
labs(x="Effect on Cens Index", title = "cens.m5") +
scale_y_discrete(labels=c("Elevation", "Elevation Quadratic", "Mass"))
cens.m5.p1
ggsave(cens.m5.p1, filename = "hb.m5.p1_Hb_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")
summary(cens.m5)

# Model 6
#color_scheme_set("red") # nice default
cens.m6.p1 <- mcmc_plot(cens.m6, pars=c("b_elev.z", "b_Ielev.zE2"),
                                    prob_outer=0.95, # 95% outer CI 
                                    prob=0.50, # 50% inner CI 
                                    point_est="mean") + # mean point est; default is median 
labs(x="Effect on Cens Index", title = "cens.m6") + 
scale_y_discrete(labels=c("Elevation", "Elevation Quadratic"))   
cens.m6.p1
ggsave(cens.m6.p1, filename = "cens.m6.p1_Hb_PosteriorEstimates&CredibleIntervals.pdf", bg="transparent", height=7, width=9, units="in")
summary(cens.m6)
```


# Hb: Collate model summaries and WAIC scores for reduced models (m5-m6)
```{r}
# Print model summaries 
sink("cens_reduced_brms_model_summaries.txt",append = TRUE)
summary(cens.m5, waic=TRUE)
summary(cens.m6, waic=TRUE)
sink()
# print(cens.test, prob=0.95) # change CI cut-off by adjusting prob; remember Bayesian default may not be 95%

# Get model WAIC scores  
cens.m5.waic <- waic(cens.m5)
cens.m6.waic <- waic(cens.m6)
cens.waics.red <- cbind(cens.m5.waic, cens.m5.waic); cens.waics.red
write.csv(cens.waics.red, "cens_brms_models_waics.red.csv") # totally unintelligible cumbersome doc w/ all pointwise comparisons
```


# cens: MODEL COMPARISON 
```{r}
# leave one out cross-validation, lowest is "best"
# if 2*standard error > delta LOOIC, models aren't necessarily distinguishable

library(loo)
sink("cens_brms_models_all_looic.txt", append=FALSE)
LOO(cens.m1, cens.m2, cens.m3, cens.m4, cens.m5, cens.m6, reloo=TRUE) 
sink()
# According to LOO, model 5 is top model 

# compare models # Just a shorter version of the above text
# loo_compare(en.loo) # Top ranked model includes no random effects 

# Calculate Bayesian R^2:
bayes_R2(cens.m2) # 0.20
bayes_R2(cens.m3) # 0.36
bayes_R2(cens.m4) # 0.40
bayes_R2(cens.m5) # 0.34
bayes_R2(cens.m6) # 0.16

# Model comparisons:
#         elpd_diff se_diff
# cens.m5  0.0       0.0   
# cens.m3 -0.3       1.3   
# cens.m4 -1.9       1.7   
# cens.m1 -3.0       3.6   
# cens.m6 -3.0       2.7   
# cens.m2 -3.4       3.3 

# Now re-run top model with unstandardized predictors to estimate strength of relationship between Xs and y:
# job::job({ # Send to a job to free up console
# hb.m4.unstandardized <- 
#   update(hb.m4,
#         newdata = final.hb,
#         formula = hb ~ 1 + elev + elev_position + mass.log + tempPC1 + precipPC1 + genotype + # use non .z names!!!!
#                intravar.mass + intravar.temp + intravar.precip + (1|species),
#         chains = 4, cores = 4)
# save(hb.m4.unstandardized, file="hb.m4.unstandardized_Predictors_SpeciesRE.RData") # save model
# })
# # load("hb.m4.unstandardized_Predictors_SpeciesRE.RData")

# Look at magnitude of unstandardized coefficients 
# summary(hb.m4.unstandardized)
# fixef(hb.m4.unstandardized)[2] # For every 1 m increase in elev, we expect Hb will increase by 0.0003885536
# round(fixef(hb.m4.unstandardized)[2]*1000, 2) # For every 1000m increase in elev, [Hb] will increase by 0.39 g/dl. 
# fixef(hb.m4.unstandardized)[3] # elev_position
# Not sure if other variables are worth reporting, as they have really obscure units
```

Quick summary of top 3 models in order of ranking: 
1) Model 5: Reduced model w/ elev, elev quadratic, and mass. R^2 = 0.34.
2) Model 3: Full model w/ elev, elev quadratic, and no genotype term. R^2 = 0.36. 
3) Model 4: Other full model w/ elev quadratic and genotype term. R^2 = 0.40



All models are NOT substantially better than the intercept-only model. No phylogenetic signal in CeNS data. 


**Some CeNS take-homes for our paper:**
- Strong relationship between CeNS index and elevation: middle elevation species appear to adjust O2 carrying capacity through more cells while lower and high elev species adjust O2 carrying capacity through increases to cell size. 
- Strong relationship between CeNS index and mass (CeNS increases w/ increased mass)
- Moderate relationship between CeNS index and wing loading (CeNS increases w/ increased WL)
- No phylogenetic signal in CeNS index 










-----

QUESTIONS FOR CHRIS 5/24/21: 
- Why are these results seemingly opposite of what we expect?! 
- Our data seem to suggest that higher altitude species increase MCV primarily as a way of increasing blood-O2 carrying capacity. But does this even make sense?! I thought the whole thing was that species want smaller cells at altitude? 
- Questions for myself, out of curiosity: Does the magnitude of difference between TRBC and MCV in driving Hb differ as you move up and down in elev? 


If I take the raw data values for TRBC/MCV+TRBC (maybe after standardizing), what do plots look like? 
```{R}
# Answer: It's nonsensical 
# test <- cens.ss.mean
# test$cindex <- 1-(test$trbc.z/(test$mcv.z + test$trbc.z))
```



----

# A test of converting between standardized and unstandardized coefficients 
**Standardized:** Necessary when predictors are on many scales; allow for comparison of relative strength of predictors; units are standard deviations (so not really real-world interpretable)
**Unstandardized:** Acceptable when all predictors have the same units; denotes the change in the dependent variable with a unit increment in the independent variable (while holding other predictors constant); units are x and y units. 
= So, each has a different purpose. We need to run our models with standardized inputs, but we want to know unstandardized beta estimates to estimate the strength of each x on y. 
This is best achieved by running the top model with unstandardized predictors and ONLY interpreting the coefficients in terms of unit change for x and y. We can attempt to convert standardized estimates to unstandardized and vice-versa (see trials below), but this results in fairly large margins of error between estimates that are hard to explain. 
```{r}
# # EQUATION FOR CONVERTING STANDARDIZED COEFFICIENTS TO UNSTANDARDIZED: 
# # standardized x1 predictor estimate * (standard deviation of y/standard deviation of x1)
# 
# # EQUATION FOR COVERTING UNSTANDARDIZED TO STANDARDIZED:
# # # b = beta * (SDx/SDy)
# # # where b = standardized coefficient; beta = unstandardized coefficient; SDx = std dev of x predictor; SDy = std dev y resp
# 
# # TEST STANDARDIZED MODEL
# job::job({ # Send this to a job so you can use the console while it runs
# st <- brm(
#   formula = bf(hb ~ 1 + mcv.z + trbc.z + (1|species)),
#   data = censdat,
#   family = gaussian(),
#   cores = 4,
#   chains = 4,
#   thin = 10,
#   warmup = 5000, # default is iter/2; shouldn't ever be larger than iter
#   iter = 10000,
#   control = list(adapt_delta = 0.99, max_treedepth = 15),
#   sample_prior = TRUE # save priors
# )
# 
# # TEST UNSTANDARDIZED MODEL
# un <- brm(
#   formula = bf(hb ~ 1 + mcv + trbc + (1|species)),
#   data = censdat,
#   family = gaussian(),
#   cores = 4,
#   chains = 4,
#   thin = 10,
#   warmup = 5000, # default is iter/2; shouldn't ever be larger than iter
#   iter = 10000,
#   control = list(adapt_delta = 0.99, max_treedepth = 15),
#   sample_prior = TRUE # save priors
# )
# })
# 
# # print summaries
# summary(st)
# summary(un)
# 
# ######
# 
# # Tutorial on converting standardized to unstandardized coefficients from Stack Exchange
# # https://stats.stackexchange.com/questions/235057/convert-standardized-coefficients-to-unstandardized-metric-coefficients-for-li
# set.seed(1)
# d=data.frame(y=1:100,x1=runif(100)+10,x2=rnorm(100)+10)
# d$y=1+ 2 * d$x1 + 3*d$x2 ## easy coef 1 2 3
# d0=d # make a copy
# m=lm(y~.,d0) # fit model
# coef(m) # coefficients are 1 2 3
# d=as.data.frame(scale(d)) # now scale it
# m2=lm(y~.,d) # re-run model
# coef(m2) #oefficients are now: -1.575657e-17  1.834809e-01  9.668451e-01
# 
# # Convert standardized to unstandardized
# coef(m2)['x1']*(sd(d0$y)/sd(d0$x1)) # Convert standardized x1 to unstandardized x1
# coef(m2)['x2']*(sd(d0$y)/sd(d0$x2)) # Convert standardized x2 to unstandardized x2
# coef(m)[1]*sd(d0$y)+mean(d0$y)- # Now determine unstandardized intercept
#   (coef(m)['x1']*sd(d0$y)*mean(d0[['x1']])/sd(d0[['x1']]) +
#    coef(m)['x2']*sd(d0$y)*mean(d0[['x2']])/sd(d0[['x2']]))
# 
# # check with our data
# summary(un)
# summary(st)
# fixef(un)[2] # MCV - unstandardized model estimate
# fixef(st)[2]*(sd(censdat$hb)/sd(censdat$mcv)) # this should give me UNSTANDARDIZED mcv
# 
# fixef(un)[3] # trbc - unstandardized model estimate
# fixef(st)[3]*(sd(censdat$hb)/sd(censdat$trbc)) # this should give me UNSTANDARDIZED mcv
# fixef(un)[1]*sd(censdat$hb)+mean(censdat$hb)- # Now determine unstandardized intercept
#   (fixef(un)[2]*sd(censdat$hb)*mean(censdat[['mcv']])/sd(censdat[['mcv']]) +
#    fixef(un)[3]*sd(censdat$hb)*mean(censdat[['trbc']])/sd(censdat[['trbc']])
#    )
# 
# # Hmm...these estimates seem a little off. Let's explore this a bit more.
# 
# # Convert unstandardized to standardized
# mcv.z.model <- round(fixef(st)[2], 2); mcv.z.model # standardized estimate from model
# mcv.z.hand <- round(fixef(un)["mcv", "Estimate"] * (sd(censdat$mcv) / sd(censdat$hb)), 2); mcv.z.hand # hand estimate
# mcv.z.diff <- mcv.z.model-mcv.z.hand; mcv.z.diff # WHY DO ESTIMATES DIFFER????
# 
# trbc.z.model <- round(fixef(st)[3], 2); trbc.z.model # standardized estimate from model
# trbc.z.hand <- round(fixef(un)["trbc", "Estimate"] * (sd(censdat$trbc) / sd(censdat$hb)), 2); trbc.z.hand # hand estimate
# trbc.z.diff <- trbc.z.model-trbc.z.hand; trbc.z.diff # WHY DO ESTIMATES DIFFER????
# 
# # Convert standardized to unstandardized - for this convertion divide std(y)/std(x)
# mcv.unest.model <- round(fixef(un)[2], 2); mcv.unest.model # MCV - unstandardized model estimate
# mcv.unest.hand <- round(fixef(st)[2]*(sd(censdat$hb)/sd(censdat$mcv)), 2); mcv.unest.hand # hand est
# mcv.unest.diff <- mcv.unest.model-mcv.unest.hand; mcv.unest.diff
# 
# trbc.unest.model <- round(fixef(un)[3], 2); trbc.unest.model # trbc - unstandardized model estimate
# trbc.unest.hand <- round(fixef(st)[3]*(sd(censdat$hb)/sd(censdat$trbc)), 2); trbc.unest.hand # hand est
# trbc.unest.diff <- trbc.unest.model-trbc.unest.hand; trbc.unest.diff
# 
# fixef(hb.m4)[-1, ] %>% round(3) # this says: print coefficients but minus the intercept
# 
# ####
# 
# # This post also explains how to convert estimates:
# # https://github.com/ASKurz/Doing-Bayesian-Data-Analysis-in-brms-and-the-tidyverse/blob/master/17.Rmd
# # Based on Kruschke's Equation 17.2, convert standardized coefficients back to their original metric using the formulas
# 
# # \begin{align*}
# # \beta_0 & = \zeta_0 \operatorname{SD}_y + M_y - \frac{\zeta_1 M_x \operatorname{SD}_y}{\operatorname{SD}_x} \;\; \text{and}  \\
# # \beta_1 & = \frac{\zeta_1 \operatorname{SD}_y}{\operatorname{SD}_x},
# # \end{align*}
# #
# # where $\zeta_0$ and $\zeta_1$ denote the intercept and slope for the model of the standardized data, respectively, and that model follows the familiar form
# #
# # $$z_{\hat y} = \zeta_0 + \zeta_1 z_x.$$
# # To implement those equations, we'll first extract the posterior samples. We begin with `fit17.1`, the model for which $N = 300$.
# 
# post <- posterior_samples(st)
# head(post)
# 
# # Let's wrap the consequences of Equation 17.2 into two functions.
# make_beta_0 <- function(zeta_0, zeta_1, sd_x, sd_y, m_x, m_y) {
#   zeta_0 * sd_y + m_y - zeta_1 * m_x * sd_y / sd_x # zeta_0 = intercept for standardized data 
# }
# make_beta_1 <- function(zeta_1, sd_x, sd_y) {
#   zeta_1 * sd_y / sd_x # zeta_1 = slope for standardized data (aka, estimate of predictor)
# }
# # where $\zeta_0$ and $\zeta_1$ denote the intercept and slope for the model of the standardized data
# 
# # After saving a few values, we're ready to use our custom functions to convert our posteriors for `b_Intercept` and `b_height_z` # to their natural metric.
# sd_x <- sd(censdat$mcv)
# sd_y <- sd(censdat$hb)
# m_x  <- mean(censdat$mcv)
# m_y  <- mean(censdat$hb)
# 
# post <- # This converts ALL model point estimates to unstandardized form. 
#   post %>% 
#   mutate(b_0 = make_beta_0(zeta_0 = b_Intercept,
#                            zeta_1 = b_mcv.z,
#                            sd_x   = sd_x,
#                            sd_y   = sd_y,
#                            m_x    = m_x,
#                            m_y    = m_y),
#          b_1 = make_beta_1(zeta_1 = b_mcv.z,
#                            sd_x   = sd_x,
#                            sd_y   = sd_y))
# glimpse(post)
# 
# # This example  confirms that yes, I'm doing the math write...but I still can't figure out why hand-estimated and model-
# # estimated numbers differ. 
```

**Conclusion** after I did quite a bit of digging: Few people convert standardized coefficients to unstandardized, but many convert unstandardized to standardized. 

While it's possible to estimate unstandardized coefficients from standardized, I come up with measurement differences between the hand-estimated and model-estimated unstandardized coefficients, and I don't like that. It seems the best approach is to: 
1) Run model sets with standardized coefficients to determine differences among predictors and strength of effects; generate posterior estimates and plots from these models --> i.e., allows you to say elevation has a stronger effect than temperature on Hb. 
2) Run the top model with unstandardized coefficients. Use this model summary to estimate the magnitude of change in y relative to each x, but DO NOT compare among x variables. --> i.e., does not allow you to compare the magnitude of effect of elevation vs. temperature on Hb, but DOES allow you to say that for every 100 m increase in elev you expect [hb] to increase by 1.0 g/dl, for example (these are not real numbers). 

More on these topics here: 
https://www.researchgate.net/post/Standardized-vs-Unstandardized-regression-coefficients
"...independent variable with a larger standardized coefficient will have a greater effect on the dependent variable.
    in interpretation of your regression results the value of any unstandardized coefficient denotes the change in the dependent variable with a unit increment in the independent variable. But you can not compare them in terms of impact on the dependent variable.
    Unstandardized coefficients are useful in interpretation and standardized coefficients in comparison of impact of any independent variable on the dependent variable.

https://www.researchgate.net/post/What-is-the-difference-between-standardized-and-unstandardized-regression-coefficient
"Unstandardized regression coefficients tell you how much change in Y (the amount is B) is predicted/estimated to occur per unit change in that independent variable (X), when all other IVs are held constant. These retain the individual scales of the IVs and the DV.
    Standardized regression coefficients tell you how much change in Y (the amount is the "beta", representing number of standard deviations) is predicted/estimated per unit (SD) change in that X, when all other IVs are held constant. These values pertain only when all variables are scaled to z-scores (mean = 0, SD = 1), and do not represent the original scale(s).
    Comparison of relative emphasis given to individual IVs is only possible when all are on a common scale, so standardized coefficients would be the ones to look at when you are trying to determine relative weight given to each IV."





# Print environment for reproducibility
```{r}
sessionInfo() # List of packages and versions in use 
```

###########

## END 

